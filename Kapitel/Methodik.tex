%Struktur
% -Festlegung von Software-Kriterien
% -Auswahl des Verfahrens
% -Reproduktion des Verfahrens aus der Literatur
% 	-Kantenerkennung
% 	-Segmentierung
%	-Probleme & besondere Erkenntnisse
% -Erweiterung des Verfahrens
%	-Grundlegende Änderungen des Verfahrens
%	-False edge removal
%	-Point marking and cloud filtering
%	-misc.


\chapter{Entwicklungsprozess der Software}
Die Rücksichtnahme des Einsatzzwecks bei der Design und Entwurf des Verfahrens sowie die Entwicklung der Software war erforderlich, um die gewünschte Funktionalitäten gewährleisten zu können. Das Verfahren soll Kanten und Geometrien nicht nur in vollständig generierten Punktwolken erkennen, sondern auch in unvollständige Punktwolken, die iterativ wachsen. Hierbei wird ein Laserliniensensor eine Kante eines Werkstücks oder Objektes entlang geführt und somit sequentiell abgetastet. Deswegen wird die räumliche Struktur des Objektes nicht in einer einzigen Aufnahme abgebildet, sondern durch mehrere kleine Einzelaufnahmen. Der intelligente Schweißroboter, der durch das Fraunhofer Institut für Produktions- und Automatisierungstechnik entwickelt wird, verwendet ein solches Verfahren zum Scannen eines Werkstückes und zur Erkennung Schweißnähte \autocite[39]{savla_intelligente_2022}. Mittels eines Lasersensors wird die Oberfläche des Werkstückes dreidimensional abgebildet. Aktuell wird eine Schweißkegelnaht durch die Erkennung der Schnittlinie zwei Ebenen markiert, die mittels RANSAC-Algorithmen auf die Punktwolke des Werkstückes gefittet werden. Dieses Verfahren zur Erkennung der Schweißnaht bietet allerdings kaum detaillierte Informationen über die Geometrie des Werkstückes an.\autocite[39-52]{savla_intelligente_2022}. Das, in dieser Arbeit entwickelte Verfahren soll das bestehende Verfahren ersetzen und somit seine Limitationen überwinden.

\begin{figure}[h]
	\includegraphics[width = \textwidth]{Abbildungen/collage.jpg}
	\centering
	\caption{Der Laserliniensensor} 
\end{figure}

\section{Vorbereitungen}
\subsection{Software-Voraussetzungen}\label{soft_voraus}
Bei der Auswahl eines geeigneten Verfahrens zur Detektierung Kanten in einer Punktwolke wurden einige Voraussetzungen festgelegt. Die Methode sollte in der Lage sein, nicht nur Außenkanten zu erkennen, sondern auch Innenkanten beziehungsweise Faltungen. Neben dem originellen Einsatzzweck sollte das Verfahren möglichst breit anwendbar sein und eine hohe Modularität aufweisen. Die Funktionen der Kantendetektierung und Punktesegmentierung sollten unabhängig von einander aufrufbar gestaltet werden, um dem Benutzer eine möglichst hohe Flexibilität anzubieten. Die Kantenerkennung sollte performant erfolgen und Punktwolken innerhalb eines praktischen Zeitraums verarbeiten. Letztlich soll das Programm in dem bestehenden Programmpaket des Schweißroboters integrierbar sein. Die Hardwarebeschleunigung des Verfahrens mittels eines Grafikprozessors wurde ausgeschlossen, da ihrer Verwendung mit dem Echtzeitkernels des Programmpakets zur Konflikte führt. 

\subsection{Auswahl eines Verfahrens}
Eine Literatursuche nach Verfahren zur adaptiven Erkennung von Kanten in wachsenden 3D Punktwolken für den Einsatzzweck ergab nichts. Die meisten Verfahren eigneten sich für die Kantenerkennung nur in vollständigen Punktwolken. Aus diesem Grund wurde die Entscheidung getroffen, ein vorhandenes Verfahren aus der Literatur zu wählen und es für den Einsatzzweck anzupassen. Drei unterschiedlichen Verfahren nach \textcite{bazazian_edc-net_2021}, \textcite{himeur_pcednet_2021} und \textcite{rachmadi_road_2017} zeigten viel versprechende Ergebnisse. Allerdings wurden neuronale Netze in dieser Verfahren verwendet, welches zu zwei Problemen geführt hätte. Aufgrund der Funktionsweise neuronaler Netze wäre es schwierig gewesen, diese für den Einsatzzweck ohne eine umständliche Anpassung des neuronalen Netzes anzupassen. Das zweite Hindernis entsteht durch die Einschränkung bei der Verwendung von Grafikprozessoren. Diese Prozessoren hätten die Rechenzeit neuronaler Netze sehr stark verringert und die schnelle Performanz des Verfahrens gewährleistet \autocite[625]{luo_artificial_2005}. Das numerische Verfahren nach \textcite{choi_rgb-d_2013} war auch für den Einsatzzweck ungeeignet, da es als Eingangsparameter eine RGB-D Datei erfordert. Somit wäre das Verfahren nur für eine Anwendung auf organisierten, gefärbten Punktwolken eingeschränkt. Es wurden zwei weitere Verfahren gefunden, die sich zur Erkennung Kanten in organisierten sowie unorganisierten Punktwolken eignen würden. \textcite{mineo_novel_2019} stellten eine numerische Methoden vor, welche zu einer hohen Genauigkeit Kanten erkennen konnte. Allerdings wurden keine Angaben über die Erkennung Innenkanten in dieser Arbeit gemacht. \textcite{ni_edge_2016} schlagen im Gegensatz eine Methode namens AGPN vor, die nicht nur Außen- sowie Innenkanten und Faltungen erkennt, sondern die erkannten Randpunkte zusammen clustert, um Kannten voneinander zu trennen. Diese Studie präsentierte ein Verfahren mit einer hohen Genauigkeit sowie eine Möglichkeit, die Randpunkte sinnvoll zusammen zu gruppieren. Aus diesem Grund wurde dieses Verfahren als Grundlage für das adaptive Verfahren dieser Arbeit gewählt.

\section{Reproduktion des AGPNs}
Bevor das Verfahren für den Einsatzzweck angepasst wurde, wurde es zuerst zwecks einer Überprüfung unverändert implementiert. Es sollte sichergestellt werden, dass das Verfahren für die Erkennung Innenkanten und potenzielle Schweißnähte geeignet ist. Da die Autoren das Quellcode ihres Verfahrens nicht öffentlich zugängig gemacht haben, musste das Programm händisch reproduziert werden. Die Reproduktion des Programms erfolgte in zwei Schritten - die Reproduktion des Verfahrens zur Kantenerkennung und dessen zur Kantensegmentierung. Obwohl andere Skriptsprachen wie Python und MATLAB hinsichtlich des Prototypings Vorteile anbieten, wurde das Programm in C++ wegen seiner besseren Leistungsfähigkeit implementiert \autocite{svensson_performance_2021}. Viele Funktionalitäten der PCL-Bibliothek \autocite{rusu_3d_2011} wurden auch zum Entwurf des Verfahrens verwendet.

\subsection{Verfahren zur Erkennung Randpunkte} \label{edge_detection_reprod}
Während Randelemente in zweidimensionale Bilder als eine klare Definition haben, fehlt eine solche Definition für Randelemente und Kanten in 3D-Punktwolken. In diesem Verfahren wurden die geometrischen Eigenschaften einer Kollektion von Punkten zur Erkennung Randpunkte berücksichtigt. Randpunkte weisen eine besondere geometrische Eigenschaft auf - der Winkelabstand zwischen benachbarten Randpunkte ist im Vergleich zu anderen benachbarten Punkten deutlich größer. Faltungen stellen den Grenzbereich zwischen zwei angrenzenden Ebenen dar, deren Normale in unterschiedlichen Richtungen zeigen. Diese geometrischen Eigenschaften wurden zur Erkennung Randpunkte verwendet. \autocite[1-2]{ni_edge_2016}

\begin{figure}[h]
	\includegraphics[scale=0.12]{Abbildungen/ablauf_plan_edge.png}
	\centering
	\caption{Das Programmablaufplan zur Erkennung Randpunkte \autocite{ni_edge_2016}.}
	\label{flow_chart}
\end{figure}

Im folgenden wird das Verfahren zur Erkennung Randpunkte detaillierter erläutert. Für einen Punkt \textit{o} wurde eine Sammlung von \textit{K\textsubscript{1}} benachbarten Punkten mittels eines kd-trees erstellt. Diese Sammlung wird als eine Nachbarschaft \textit{N\textsubscript{o}} referiert. Danach wurde mittels eines RANSAC-Algorithmus eine Ebene \textit{E\textsubscript{N}} auf diese Nachbarschaft gefittet, um Ausreißer herauszufiltern und zwei angrenzenden Flächen innerhalb der Nachbarschaft voneinander zu trennen. Danach wurde Überprüft, ober der Punkt \textit{o} auf der RANSAC-Ebene lag. Falls dieser Punkt ein Ausreißer der Ebene \textit{E\textsubscript{N}} war, wurde er nicht als einen Randpunkt markiert. Ansonsten wurden weiterhin die geometrischen Eigenschaften der Nachbarschaft überprüft. Abbildung \ref{RANSAC-Ebene} visualisiert die Trennung zwischen unterschiedlichen Flächen einer Punktwolke mittels des RANSAC-Verfahrens. 

\begin{figure}[h]
	\includegraphics[width=\textwidth]{Abbildungen/RANSAC-Ebene.png}
	\centering
	\caption{Eine lokale RANSAC-Ebene (rot dargestellt) neben anderen Oberflächen (blau dargestellt). In \textbf{a} sind drei Ebenen zu sehen, wobei in \textbf{b} nur zwei zu sehen sind. \autocite{ni_edge_2016}}
	\label{RANSAC-Ebene}
\end{figure} 

Im Falle, dass der Punkt \textit{o} ein Inlier war und zu der Ebene \textit{E\textsubscript{N\textsubscript{o}}} gehörte, fang die tatsächliche Überprüfung der geometrischen Eigenschaften der Nachbarschaft \textit{N\textsubscript{o}} an. Um die Ebenengleichung von \textit{E\textsubscript{N}} näherungsweise zu schätzen, wurde zuerst die Normale \textit{$\vec{n}$} der Ebene geschätzt. In einer effizienten Weise wurde die Ebenengleichung durch das RANSAC-Verfahren näherungsweise geschätzt. Diese Gleichung wurde weiterhin auf die RANSAC-Inliers optimiert und daraus die Normale \textit{$\vec{n}$} ermittelt. Danach erfolgte die Errechnung des Winkelabstands zwischen den jeweiligen Punkten von \textit{N\textsubscript{o}}. Hierfür wurden für die Ebene \textit{E\textsubscript{N}} die jeweiligen Eigenvektoren $\vec{u}$ und $\vec{v}$ aus der Normale $\vec{n}$ errechnet. Das fertige Verfahren von PCL zur Ausrechnung der Eigenvektoren lieferte ungenaue Ergebnisse. Stattdessen wurden zur Ermittelung \textit{$\vec{u}$} zwei zufällig gewählte Punkten aus der Inliers verwendet. Es wurde dabei sichergestellt, dass keiner der Punkten den Punkt \textit{o} entsprachen. Zur Errechnung des Winkelabstands wurden zuerst die Winkel aller Punkte der lokalen Ebene \textit{E\textsubscript{N}} errechnet. Mit dem Punkt \textit{o} als Ursprung wurde für jeden Punkt \textit{p\textsubscript{i}}, aus \textit{N\textsubscript{r}} Punkten, der Winkel \textit{$\theta_i$} zu einer Nulllinie errechnet. Danach wurde die Differenz zwischen zwei konsekutiver Punktwinkel $\theta_i$ und $\theta_{i+1}$ errechnet, welcher den Winkelabstand \textit{G\textsubscript{$\theta$}} zwischen zwei Punkten \textit{p\textsubscript{i}} und \textit{p\textsubscript{i+1}} betrug. Bei einer Winkelabstand größer als ein bestimmter Schwellenwert wurde der Punkt \textit{o} als einen Randpunkt markiert. Das Referenzwerk verwendete einen Schwellenwert von $\frac{\pi}{2}$. Abbildung \ref{edge_boundary} zeigt, wie der Winkelabstand zwischen Punkten am Rand der Punktwolke aussieht.

\begin{figure}[h]
	\includegraphics[width=0.5\textwidth]{Abbildungen/angular_gap_boundary}
	\centering
	\caption{Der Winkelabstand \textit{G\textsubscript{$\theta$}} zwischen Punkten am Rand der Punktwolke. \textbf{\(a\)} zeigt ein interner Punkt \textit{o}und ein Nachbarpunkt \textit{p\textsubscript{i}}. Im Vergleich dazu zeigt \textbf{\(b\)} \textit{o} am Rand und den großen Winkelabstand \textit{G\textsubscript{$\theta$}} zwischen Punkte \textit{p\textsubscript{i}} und \textit{p\textsubscript{i + 1}}. \autocite{ni_edge_2016}}
	\label{edge_boundary}
\end{figure}

Auch die Erkennung von Punkten in Innen- und Außenkanten war durch diese Berechnungen möglich. Wie bereits erwähnt, wurden zwei angrenzenden Flächen mittels das RANSAC-Verfahren voneinander getrennt. Falls der Punkt \textit{o} auf der Schnittlinie beider Flächen sowie auf der lokalen RANSAC-Ebene \textit{E\textsubscript{N}} liegt, dann gehört es zum lokalen Rand der Ebene. Falls der Punkt \textit{o} auf der Schnittlinie beider Flächen liegt, aber nicht zu der RANSAC-Ebene gehört, wird es automatisch nicht als einen Randpunkt gemerkt. \textit{E\textsubscript{N}}. Die Abbildung \ref{edge_fold} zeigt, wie der Winkelabstand zwischen Punkten auf einer Schnittlinie zwischen zwei Flächen der Punktwolke aussieht. Die Errechnungen des Winkelabstands erfolgte nach den Gleichungen \ref{first_equation} - \ref{last_equation}.

\begin{figure}[h]
	\includegraphics[width=\textwidth]{Abbildungen/angular_gap_fold}
	\centering
	\caption{Der Winkelabstand zwischen Punkten auf einer Schnittlinie zwei angrenzender Flächen. \textbf{\(a\)} zeigt ein interner Punkt \textit{o} der RANSAC-Ebene. \textbf{\(b\)} zeigt \textit{o} am lokalen Rand der RANSAC-Ebene und den Winkelabstand \textit{G\textsubscript{$\theta$}} zwischen Punkte \textit{p\textsubscript{i}} und \textit{p\textsubscript{i + 1}}. \textbf{\(c\)} zeigt \textit{o} als ein Ausreißer der RANSAC-Ebene. \autocite{ni_edge_2016}}
	\label{edge_fold}
\end{figure}

\begin{equation}
\label{first_equation}
d_i^u = \vec{{op}_i} \cdot \vec{u}
\end{equation}
\begin{equation}
d_i^v = \vec{{op}_i} \cdot \vec{v}
\end{equation}
\begin{equation}
\theta_i = \arctan{\frac{d_i^u}{d_i^v}}
\end{equation}
\begin{equation}
G_\theta = \max(\theta_{i + 1} - \theta_i), i \in \{1, \ldots, N_r - 1\},
\label{last_equation}
\end{equation}


Um die Genauigkeit des Verfahrens zu versichern und die Rechenarbeit des Verfahrens zu verringern, wurden gezielt zwei zusätzliche Schritte vor dem Erkennungsverfahren eingeführt. Um die Anzahl der Punkte in der Punktwolke zu verringern wurde ein Voxel-Grid basiertes Downsampling-Verfahren implementiert, um die Punktdichte der Punktwolke künstlich anzupassen und den Abstand zwischen Punkten vereinheitlichen. Hierfür wurde die PCL-Funktion \textit{UniformSampling} verwendet \autocite{noauthor_point_2023}. Um Ausreißer aus der Punktwolke zu entfernen, wurde das statistische Verfahren zur Ausreißer-Entfernung der PCL-Bibliothek verwendet \autocite{rusu_towards_2008}. Zur Korrekten Ausrechnung des maximalen Winkelabstands einer Nachbarschaft \textit{G\textsubscript{$\theta$}} war eine aufsteigende Sortierung der Winkel \textit{$\theta_i$} notwendig. Diese Sortierung entsprach eine Sortierung der Punkte \textit{p\textsubscript{i}} nach ihrer aufsteigenden polaren Entfernung von der Nulllinie. Die Abbildung \ref{vector_graph} dient zur Visualisierung der Methode zur Ausrechnung von $\theta_i$. Die Eigenvektoren $\vec{u}$ und $\vec{v}$ bildeten das zweidimensionale Koordinatensystem, wobei $\vec{v}$ analog zu einer x-Achse agierte. Die Skalarprodukte \textit{d\textsubscript{i}\textsuperscript{u}} und \textit{d\textsubscript{i}\textsuperscript{v}} repräsentierten die parallelen Anteile des Vektors $\vec{{op}_i}$ der jeweiligen Eigenvektoren $\vec{u}$ und $\vec{v}$. Somit ließ sich der Winkel $\theta_i$ eines Punktes \textit{p\textsubscript{i}} zu der Nulllinie beziehungsweise dem Vektor $\vec{v}$ errechnen. Abbildung \ref{edge_points_table} zeigt die erkannten Randpunkte einer dreidimensionalen Abbildung eines Tisches.

\begin{figure}[t]
	\includegraphics[scale=0.7]{Abbildungen/vector_graph.png}
	\centering
	\caption{Diese Abbildung stellt die Berechnung des Winkels $\theta_i$ graphisch dar}
	\label{vector_graph}
\end{figure}

\begin{figure}[h]
	\includegraphics[scale=0.37]{Abbildungen/table_edge_overlay.png}
	\centering
	\caption{Die braune Punkte bilden die Randpunkte ab, die in der blauen Punktwolke durch das Verfahren erkannt wurden}
	\label{edge_points_table}
\end{figure}

Zusammenfassend wurde für jeden Punkt \textit{o} aus der Punktwolke eine RANSAC-Ebene \textit{E\textsubscript{N}} aus einer lokalen Nachbarschaften des Punktes mit \textit{K\textsubscript{1}} Punkten erstellt. Falls \textit{o} in der Ebene lag, und der größte Winkelabstand zwischen Punkten der Ebene mit \textit{o} als den Ursprung größer als $\frac{\pi}{2}$ betrug, wurde \textit{o} als ein Randpunkt markiert und gespeichert. Durch die Wiederholung dieser Schritte für alle Punkte wurden alle Randpunkte der Punktwolke identifiziert. Abbildung \ref{flow_chart} stellt den Programmablaufplan für dieses Verfahren dar. Die Probleme bei der Reproduktion dieses Verfahrens werden im Abschnitt \ref{label} besprochen.

\subsection{Verfahren zur Segmentierung Randpunkte}
Nachdem die Randpunkte der Punktwolke erkannt wurden, folgte die Segmentierung der Randpunkte zu Kanten. Hierbei wurden alle Randpunkte zusammen gruppiert, die zu einem geometrischen Merkmal des gescannten Objektes gehörten. Hierfür wurde ein Region-Growing Verfahren verwendet. Punkte wurden auf Basis zwei Kriterien segmentiert. Das erste Kriterium besagte, dass nur Punkte, die nah aneinander lagen, einen Cluster bilden können. Das zweite Kriterium besagte, dass nur Punkte, die in einer ähnlichen Hauptrichtung zeigten, zusammen geclustert werden dürfen. Die Segmentierung erfolgte hauptsächlich in zwei Schritten - die Erstellung und Exaktifizierung von Nachbarschaften sowie die Region-Growing Segmentierung der Randpunkte.

Bei dem ersten Schritt handelte es sich um die Berechnung der Richtungsvektoren und die Bestimmung der exakten Nachbarpunkte jedes Randpunktes. Für einen Randpunkt \textit{p} wurden \textit{K\textsubscript{2}} Nachbarpunkte aus den, in Abschnitt \ref{edge_detection_reprod} gefunden Randpunkten, gesucht. Diese Sammlung wurde als die Nachbarschaft \textit{N\textsubscript{p}} referenziert. Danach wurde eine Linie \textit{L\textsubscript{N}} mittels eines RANSAC-Verfahrens auf die Nachbarschaft gefittet, um alle Punkte zu finden, die in der gleichen Hauptrichtung zeigten. Falls der Randpunkt \textit{p} nicht zu den Inliers der RANSAC-Linie gehörte, wurde iterativ auf die Ausreißer das RANSAC-Verfahren wieder implementiert, bis \textit{p} zu den Inliers von \textit{L\textsubscript{N}} gehörte. Danach wurden alle Punkte der Linie \textit{L\textsubscript{N}} als die exaktifizierten Nachbarpunkte des Punktes \textit{p} gespeichert. Der, aus \textit{L\textsubscript{N}} ermittelte Richtungsvektor wurde dem Punkt \textit{p} zugeordnet. Somit wurde die Vorarbeit zur Erfüllung des ersten Kriteriums erfüllt.

Nachdem es für jeden Punkt einen Hauptrichtungsvektor und eine exakte Nachbarschaft ermittelt wurde, wurde das Region-Growing Verfahren für die Segmentierung Randpunkte implementiert. Hierfür wurde das bestehende Region-Growing Verfahren der PCL-Bibliothek adaptiert \autocite{rusu_3d_2011}. Zuerst wurden alle Punkte mit dem Label \textit{-1} markiert, um diese als \textit{unsegmentiert} kennzuzeichnen. Das Referenzwerk deutete auf die Irreversibilität des Verfahrens hin, weswegen die Auswahl eines guten Startpunktes sehr wichtig war. Randpunkte mit einer hohen Anzahl von exakten Nachbarn konnten mit einer höheren Wahrscheinlichkeit eine Kante oder ein geometrisches Merkmal abbilden. Deswegen wurden alle Randpunkte nach einer absteigenden Anzahl von Nachbarpunkte sortiert, sodass die Auswahl eines guten Startpunktes gewährleistet wurde. Für den zuwachs eines Segments \textit{C} wurde ein initialer Seedpunkt \textit{s\textsubscript{i}} gewählt, welcher im Falle des ersten Segments der Startpunkt war. Für jeden unmarkierten (durch \textit{-1} gekennzeichnet) exakten Nachbarpunkt \textit{n\textsubscript{s}} von \textit{s} wurde geprüft, ob desen Hauptrichtungsvektor mit dem des Seedpunktes näherungsweise übereinstimmten. Dies erfolgte durch die Berechnung des Winkelabstands zwischen beiden Hauptrichtungsvektoren, der nicht einen Schwellwert $\phi$ nicht übersteigen durfte. Falls der Richtungsvektor des Nachbarpunktes mit dem des Seedpunktes übereinstimmte, wurde es dem Segment \textit{C} hinzugefügt und mit dem Index des Segments markiert. Danach wurde \textit{n\textsubscript{s}} zu einer Sammlung neuer Seedpunkte \textit{s\textsubscript{c}} hinzugefügt, die für den weiteren Zuwachs des Segments \textit{C} verwendet wurden. Nachdem alle exakte Nachbarpunkte von \textit{s\textsubscript{i}} markiert worden waren, wurde dieser Schritt für alle neue \textit{s\textsubscript{c}} wiederholt, bis es keiner Punkte mit dem Richtungsvektor von \textit{s\textsubscript{i}} übereinstimmten. Danach wurde ein neuer unmarkierter initialer Seedpunkt \textit{s\textsubscript{i}} gewählt und das ganze Verfahren wiederholt. Im Anhang \ref{label} wird das Verfahren ausführlicher als Pseudocode angegeben. Die Abbildung \ref{segments_table} zeigt alle Segmente in unterschiedlichen Farben an, die durch Region-Growing Verfahren aus den Randpunkten des Tisches erkannt wurden.

\begin{figure}[h]
	\includegraphics[width=\textwidth]{Abbildungen/table_segments.png}
	\centering
	\caption{Diese Abbildung zeigt die, durch das Verfahren erkannte  Segmente des Tisches aus Abbildung \ref{edge_points_table}.}
	\label{segments_table}
\end{figure}

\subsection{Probleme bei der Reproduktion des AGPNs}
Bei der Reproduktion des AGPN Verfahrens tauchten ein paar Probleme auf, die entweder eine korrekte Erkennung Randpunkte verhinderten oder die Performanz des Verfahrens beeinträchtigen. Das Verfahren zur Erkennung Randpunkte sollte möglichts schnell efolgen, um für den Einsatz in der Schweißrobotik geeignet zu sein. Durch die Implementierung des Programmes in C++ erfolgte die Erkennung von Randpunkten schneller im Vergleich zu anderen Sprachen wie Python oder MATLAB. Allerdings wurde die Leistungsfähigkeit moderner Rechner und CPUs durch das Programm nicht völlig ausgeschöpft. Moderne Mehrkernprozessoren bieten die Funktionalität an, Aufgaben parallel auszuführen. Isolierte Rechenaufgaben, die möglichst homogen bleiben und wiederholt werden, lassen sich sehr gut parallelisieren. Die Schritte zur Bestimmung eines Randpunktes wurden in einer Schleife für jeden Punkt der Punktwolke wiederholt, weswegen sie sich zur Parallelisierung eigneten. Die Programmierschnittstelle OpenMP bietet über Compiler-Befehle die Möglichkeit an, Prozesse in C, C++ und Fortran zu parallelisieren. Das Schleifenelement des Verfahrens wurde mittels OpenMP parallelisiert, da die Bestimmung eines Punktes als einen Randpunkt keinen Einfluss auf die Bestimmung anderer Randpunkte hatte, und somit eine isolierte Aufgabe darstellt. Es musste auch sichergestellt werden, dass eine Variable in einer Speicheradresse nicht gleichzeitig durch zwei oder mehrere parallelen Instanzen der Schleife überschrieben wird. Auch Datenstrukturen mussten sorgfältig nach ihrer Eignung zur Parallelisierung gewählt werden, um Speicherlecks zu vermeiden. Auch die Berechnung des Winkels $\theta_i$ für jeden Punkt der RANSAC-Ebene \textit{E\textsubscript{N}} wurde parallelisiert. Durch diese nebenläufige Programmierung wurde auf einem Ryzen 5 3600 Prozessor \autocite{noauthor_amd_2022} mit sechs Kernen und 12 Threads und einer Basistaktrate von 3,6 GHz eine siebenfache Leistungsverbesserung beobachtet. Eine Punktwolke mit ca. 450.000 Punkte wurde vor der Parallelisierung innerhalb 162 Sekunden verarbeitet. Nach der Parallelisierung erfolgte die Erkennung Randpunkte innerhalb 22,5 Sekunden. Es ließ sich postulieren, dass Randpunkte durch die Verwendung eines Prozessors mit mehr Kernen noch schneller erkannt werden könnten. Die Verwendung eines Grafikprozessors, die deutlich mehr Kernen besitzen, hätte die Erkennung Randpunkte in sehr großen Punktwolken blitzschnell machen können. Allerdings, konnte diese aufgrund der Software-Voraussetzungen in Abschnitt \ref{soft_voraus} nach einem Grafikprozessor verlagert werden.

Das zweite Problem bei der Reproduktion des AGPN Verfahrens tauchte auf, als das Programm auf zwei unterschiedlichen Versionen des Ubuntu Betriebssystems ausgeführt wurde. Die Erkennung Randpunkte erfolgt auf die neuere Version des Betriebssystems - Ubuntu Jammy Jellyfish (Version 22.04) - reibungslos und lieferte sehr gute Ergebnisse. Die Wiederholung des Programms auf eine ältere Generation des Betriebssystems - Ubuntu Focal Fossa (Version 20.04) - lieferte im Gegensatz schlechtere Ergebnisse. Ein Fehler des Rechners wurde ausgeschlossen, indem der gleiche Rechner mit konstanten Spezifikationen für beide Betriebssysteme verwendet wurde. Auch der Einfluss fremder Softwarepakete auf dem Programm wurde ausgeschlossen, indem das Programm an Betriebssysteme nur mit den notwendigen Softwareabhängigkeiten ausführt wurde. Eine genauere Untersuchung lieferte den Hinweis, dass die Standardversion der PCL-Bibliothek für beide Betriebssysteme unterschiedlich war. Die PCL-Bibliotheksversion 1.10 wurde Standardweise mit Ubuntu Focal Fossa geliefert, wobei die Version 1.12 Standardweise mit Ubuntu Jammy Jellyfish geliefert wurde. Das Downsampling-Verfahren aus der Bibliotheksversion 1.10 konnte sehr dichte Punktwolken nicht korrekt verarbeiten. Dieses Fehler wurde allerdings in der neueren Version der Bibliothek behoben. Deswegen wurde für das Betriebssystem Ubuntu Focal Fossa die Standardversion der PCL-Bibliothek entfernt und die Version 1.12 installiert. Abbildung \ref{bad_edges} zeigt die Randpunkte, die nach dem fehlerhaften Downsampling erkannt wurden.

\begin{figure}[h]
	\includegraphics[width=\textwidth]{Abbildungen/blech_bad_edges.png}
	\centering
	\caption{Randpunkte, die mit der PCL-Version 1.10 erkannt wurden.}
	\label{bad_edges}
\end{figure}

Nachdem die Funktionsweise des AGPNs getestet wurde, war der nächste Schritt die Erweiterung des Verfahrens, um die Kantenerkennung und Segmentierung für wachsenden Punktwolken zu ermöglichen.

\section{Erweiterung des AGPNs}
\subsection{Anpassung der Erkennungs- und Segmentierungsverfahren}


