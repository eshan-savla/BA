%Struktur
% -Festlegung von Software-Kriterien
% -Auswahl des Verfahrens
% -Reproduktion des Verfahrens aus der Literatur
% 	-Kantenerkennung
% 	-Segmentierung
%	-Probleme & besondere Erkenntnisse
% -Erweiterung des Verfahrens
%	-Grundlegende Änderungen des Verfahrens
%	-False edge removal
%	-Point marking and cloud filtering
%	-misc.


\chapter{Entwicklungsprozess der Software}
Die Rücksichtnahme des Einsatzzwecks bei der Design und Entwurf des Verfahrens sowie die Entwicklung der Software war erforderlich, um die gewünschte Funktionalitäten gewährleisten zu können. Das Verfahren soll Kanten und Geometrien nicht nur in vollständig generierten Punktwolken erkennen, sondern auch in unvollständige Punktwolken, die iterativ wachsen. Hierbei wird ein Laserliniensensor eine Kante eines Werkstücks oder Objektes entlang geführt und somit sequentiell abgetastet. Deswegen wird die räumliche Struktur des Objektes nicht in einer einzigen Aufnahme abgebildet, sondern durch mehrere kleine Einzelaufnahmen. Der intelligente Schweißroboter, der durch das Fraunhofer Institut für Produktions- und Automatisierungstechnik entwickelt wird, verwendet ein solches Verfahren zum Scannen eines Werkstückes und zur Erkennung Schweißnähte \autocite[39]{savla_intelligente_2022}. Mittels eines Lasersensors wird die Oberfläche des Werkstückes dreidimensional abgebildet. Aktuell wird eine Schweißkegelnaht durch die Erkennung der Schnittlinie zwei Ebenen markiert, die mittels RANSAC-Algorithmen auf die Punktwolke des Werkstückes gefittet werden. Dieses Verfahren zur Erkennung der Schweißnaht bietet allerdings kaum detaillierte Informationen über die Geometrie des Werkstückes an.\autocite[39-52]{savla_intelligente_2022}. Das, in dieser Arbeit entwickelte Verfahren soll das bestehende Verfahren ersetzen und somit seine Limitationen überwinden.

\begin{figure}[h]
	\includegraphics[width = \textwidth]{Abbildungen/collage.jpg}
	\centering
	\caption{Der Laserliniensensor} 
\end{figure}

\section{Vorbereitungen}
\subsection{Software-Voraussetzungen}\label{soft_voraus}
Bei der Auswahl eines geeigneten Verfahrens zur Detektierung Kanten in einer Punktwolke wurden einige Voraussetzungen festgelegt. Die Methode sollte in der Lage sein, nicht nur Außenkanten zu erkennen, sondern auch Innenkanten beziehungsweise Faltungen. Neben dem originellen Einsatzzweck sollte das Verfahren möglichst breit anwendbar sein und eine hohe Modularität aufweisen. Die Funktionen der Kantendetektierung und Punktesegmentierung sollten unabhängig von einander aufrufbar gestaltet werden, um dem Benutzer eine möglichst hohe Flexibilität anzubieten. Die Kantenerkennung sollte performant erfolgen und Punktwolken innerhalb eines praktischen Zeitraums verarbeiten. Letztlich soll das Programm in dem bestehenden Programmpaket des Schweißroboters integrierbar sein. Die Hardwarebeschleunigung des Verfahrens mittels eines Grafikprozessors wurde ausgeschlossen, da ihrer Verwendung mit dem Echtzeitkernels des Programmpakets zur Konflikte führt. 

\subsection{Auswahl eines Verfahrens}
Eine Literatursuche nach Verfahren zur adaptiven Erkennung von Kanten in wachsenden 3D Punktwolken für den Einsatzzweck ergab nichts. Die meisten Verfahren eigneten sich für die Kantenerkennung nur in vollständigen Punktwolken. Aus diesem Grund wurde die Entscheidung getroffen, ein vorhandenes Verfahren aus der Literatur zu wählen und es für den Einsatzzweck anzupassen. Drei unterschiedlichen Verfahren nach \textcite{bazazian_edc-net_2021}, \textcite{himeur_pcednet_2021} und \textcite{rachmadi_road_2017} zeigten viel versprechende Ergebnisse. Allerdings wurden neuronale Netze in dieser Verfahren verwendet, welches zu zwei Problemen geführt hätte. Aufgrund der Funktionsweise neuronaler Netze wäre es schwierig gewesen, diese für den Einsatzzweck ohne eine umständliche Anpassung des neuronalen Netzes anzupassen. Das zweite Hindernis entsteht durch die Einschränkung bei der Verwendung von Grafikprozessoren. Diese Prozessoren hätten die Rechenzeit neuronaler Netze sehr stark verringert und die schnelle Performanz des Verfahrens gewährleistet \autocite[625]{luo_artificial_2005}. Das numerische Verfahren nach \textcite{choi_rgb-d_2013} war auch für den Einsatzzweck ungeeignet, da es als Eingangsparameter eine RGB-D Datei erfordert. Somit wäre das Verfahren nur für eine Anwendung auf organisierten, gefärbten Punktwolken eingeschränkt. Es wurden zwei weitere Verfahren gefunden, die sich zur Erkennung Kanten in organisierten sowie unorganisierten Punktwolken eignen würden. \textcite{mineo_novel_2019} stellten eine numerische Methoden vor, welche zu einer hohen Genauigkeit Kanten erkennen konnte. Allerdings wurden keine Angaben über die Erkennung Innenkanten in dieser Arbeit gemacht. \textcite{ni_edge_2016} schlagen im Gegensatz eine Methode namens AGPN vor, die nicht nur Außen- sowie Innenkanten und Faltungen erkennt, sondern die erkannten Randpunkte zusammen clustert, um Kannten voneinander zu trennen. Diese Studie präsentierte ein Verfahren mit einer hohen Genauigkeit sowie eine Möglichkeit, die Randpunkte sinnvoll zusammen zu gruppieren. Aus diesem Grund wurde dieses Verfahren als Grundlage für das adaptive Verfahren dieser Arbeit gewählt.

\section{Reproduktion des AGPNs}
Bevor das Verfahren für den Einsatzzweck angepasst wurde, wurde es zuerst zwecks einer Überprüfung unverändert implementiert. Es sollte sichergestellt werden, dass das Verfahren für die Erkennung Innenkanten und potenzielle Schweißnähte geeignet ist. Da die Autoren das Quellcode ihres Verfahrens nicht öffentlich zugängig gemacht haben, musste das Programm händisch reproduziert werden. Die Reproduktion des Programms erfolgte in zwei Schritten - die Reproduktion des Verfahrens zur Kantenerkennung und dessen zur Kantensegmentierung. Obwohl andere Skriptsprachen wie Python und MATLAB hinsichtlich des Prototypings Vorteile anbieten, wurde das Programm in C++ wegen seiner besseren Leistungsfähigkeit implementiert \autocite{svensson_performance_2021}. Viele Funktionalitäten der PCL-Bibliothek \autocite{rusu_3d_2011} wurden auch zum Entwurf des Verfahrens verwendet.

\subsection{Verfahren zur Erkennung Randpunkte}
Während Randelemente in zweidimensionale Bilder als eine klare Definition haben, fehlt eine solche Definition für Randelemente und Kanten in 3D-Punktwolken. In diesem Verfahren wurden die geometrischen Eigenschaften einer Kollektion von Punkten zur Erkennung Randpunkte berücksichtigt. Randpunkte weisen eine besondere geometrische Eigenschaft auf - der Winkelabstand zwischen benachbarten Randpunkte ist im Vergleich zu anderen benachbarten Punkten deutlich größer. Faltungen stellen den Grenzbereich zwischen zwei angrenzenden Ebenen dar, deren Normale in unterschiedlichen Richtungen zeigen. Diese geometrischen Eigenschaften wurden zur Erkennung Randpunkte verwendet. \autocite[1-2]{ni_edge_2016}

\begin{figure}[h]
	\includegraphics[scale=0.12]{Abbildungen/ablauf_plan_edge.png}
	\centering
	\caption{Das Programmablaufplan zur Erkennung Randpunkte \autocite{ni_edge_2016}.}
	\label{flow_chart}
\end{figure}

Im folgenden wird das Verfahren zur Erkennung Randpunkte detaillierter erläutert. Für einen Punkt \textit{o} wurde eine Sammlung von \textit{K\textsubscript{1}} benachbarten Punkten mittels eines kd-trees erstellt. Diese Sammlung wird als eine Nachbarschaft \textit{N\textsubscript{o}} referiert. Danach wurde mittels eines RANSAC-Algorithmus eine Ebene \textit{E\textsubscript{N}} auf diese Nachbarschaft gefittet, um Ausreißer herauszufiltern und zwei angrenzenden Flächen innerhalb der Nachbarschaft voneinander zu trennen. Danach wurde Überprüft, ober der Punkt \textit{o} auf der RANSAC-Ebene lag. Falls dieser Punkt ein Ausreißer der Ebene \textit{E\textsubscript{N}} war, wurde er nicht als einen Randpunkt markiert. Ansonsten wurden weiterhin die geometrischen Eigenschaften der Nachbarschaft überprüft. Abbildung \ref{RANSAC-Ebene} visualisiert die Trennung zwischen unterschiedlichen Flächen einer Punktwolke mittels des RANSAC-Verfahrens. 

\begin{figure}[h]
	\includegraphics[width=\textwidth]{Abbildungen/RANSAC-Ebene.png}
	\centering
	\caption{Eine lokale RANSAC-Ebene (rot dargestellt) neben anderen Oberflächen (blau dargestellt). In \textbf{a} sind drei Ebenen zu sehen, wobei in \textbf{b} nur zwei zu sehen sind. \autocite{ni_edge_2016}}
	\label{RANSAC-Ebene}
\end{figure} 

Im Falle, dass der Punkt \textit{o} ein Inlier war und zu der Ebene \textit{E\textsubscript{N\textsubscript{o}}} gehörte, fang die tatsächliche Überprüfung der geometrischen Eigenschaften der Nachbarschaft \textit{N\textsubscript{o}} an. Um die Ebenengleichung von \textit{E\textsubscript{N}} näherungsweise zu schätzen, wurde zuerst die Normale \textit{$\vec{n}$} der Ebene geschätzt. In einer effizienten Weise wurde die Ebenengleichung durch das RANSAC-Verfahren näherungsweise geschätzt. Diese Gleichung wurde weiterhin auf die RANSAC-Inliers optimiert und daraus die Normale \textit{$\vec{n}$} ermittelt. Danach erfolgte die Errechnung des Winkelabstands zwischen den jeweiligen Punkten von \textit{N\textsubscript{o}}. Hierfür wurden für die Ebene \textit{E\textsubscript{N}} die jeweiligen Eigenvektoren $\vec{u}$ und $\vec{v}$ aus der Normale $\vec{n}$ errechnet. Das fertige Verfahren von PCL zur Ausrechnung der Eigenvektoren lieferte ungenaue Ergebnisse. Stattdessen wurden zur Ermittelung \textit{$\vec{u}$} zwei zufällig gewählte Punkten aus der Inliers verwendet. Es wurde dabei sichergestellt, dass keiner der Punkten den Punkt \textit{o} entsprachen. Zur Errechnung des Winkelabstands wurden zuerst die Winkel aller Punkte der lokalen Ebene \textit{E\textsubscript{N}} errechnet. Mit dem Punkt \textit{o} als Ursprung wurde für jeden Punkt \textit{p\textsubscript{i}}, aus \textit{N\textsubscript{r}} Punkten, der Winkel \textit{$\theta_i$} zu einer Nulllinie errechnet. Danach wurde die Differenz zwischen zwei konsekutiver Punktwinkel $\theta_i$ und $\theta_{i+1}$ errechnet, welcher den Winkelabstand \textit{G\textsubscript{$\theta$}} zwischen zwei Punkten \textit{p\textsubscript{i}} und \textit{p\textsubscript{i+1}} betrug. Bei einer Winkelabstand größer als ein bestimmter Schwellenwert wurde der Punkt \textit{o} als einen Randpunkt markiert. Das Referenzwerk verwendete einen Schwellenwert von $\frac{\pi}{2}$. Abbildung \ref{edge_boundary} zeigt, wie der Winkelabstand zwischen Punkten am Rand der Punktwolke aussieht.

\begin{figure}[h]
	\includegraphics[width=0.5\textwidth]{Abbildungen/angular_gap_boundary}
	\centering
	\caption{Der Winkelabstand \textit{G\textsubscript{$\theta$}} zwischen Punkten am Rand der Punktwolke. \textbf{\(a\)} zeigt ein interner Punkt \textit{o}und ein Nachbarpunkt \textit{p\textsubscript{i}}. Im Vergleich dazu zeigt \textbf{\(b\)} \textit{o} am Rand und den großen Winkelabstand \textit{G\textsubscript{$\theta$}} zwischen Punkte \textit{p\textsubscript{i}} und \textit{p\textsubscript{i + 1}}. \autocite{ni_edge_2016}}
	\label{edge_boundary}
\end{figure}

Auch die Erkennung von Punkten in Innen- und Außenkanten war durch diese Berechnungen möglich. Wie bereits erwähnt, wurden zwei angrenzenden Flächen mittels das RANSAC-Verfahren voneinander getrennt. Falls der Punkt \textit{o} auf der Schnittlinie beider Flächen sowie auf der lokalen RANSAC-Ebene \textit{E\textsubscript{N}} liegt, dann gehört es zum lokalen Rand der Ebene. Falls der Punkt \textit{o} auf der Schnittlinie beider Flächen liegt, aber nicht zu der RANSAC-Ebene gehört, wird es automatisch nicht als einen Randpunkt gemerkt. \textit{E\textsubscript{N}}. Die Abbildung \ref{edge_fold} zeigt, wie der Winkelabstand zwischen Punkten auf einer Schnittlinie zwischen zwei Flächen der Punktwolke aussieht. Die Errechnungen des Winkelabstands erfolgte nach den Gleichungen \ref{first_equation} - \ref{last_equation}.

\begin{figure}[h]
	\includegraphics[width=\textwidth]{Abbildungen/angular_gap_fold}
	\centering
	\caption{Der Winkelabstand zwischen Punkten auf einer Schnittlinie zwei angrenzender Flächen. \textbf{\(a\)} zeigt ein interner Punkt \textit{o} der RANSAC-Ebene. \textbf{\(b\)} zeigt \textit{o} am lokalen Rand der RANSAC-Ebene und den Winkelabstand \textit{G\textsubscript{$\theta$}} zwischen Punkte \textit{p\textsubscript{i}} und \textit{p\textsubscript{i + 1}}. \textbf{\(c\)} zeigt \textit{o} als ein Ausreißer der RANSAC-Ebene. \autocite{ni_edge_2016}}
	\label{edge_fold}
\end{figure}

\begin{equation}
\label{first_equation}
d_i^u = \vec{{op}_i} \cdot \vec{u}
\end{equation}
\begin{equation}
d_i^v = \vec{{op}_i} \cdot \vec{v}
\end{equation}
\begin{equation}
\theta_i = \arctan{\frac{d_i^u}{d_i^v}}
\end{equation}
\begin{equation}
G_\theta = \max(\theta_{i + 1} - \theta_i), i \in \{1, \ldots, N_r - 1\},
\label{last_equation}
\end{equation}


Zur Korrekten Ausrechnung des maximalen Winkelabstands einer Nachbarschaft \textit{G\textsubscript{$\theta$}} war eine aufsteigende Sortierung der Winkel \textit{$\theta_i$} notwendig. Diese Sortierung entsprach eine Sortierung der Punkte \textit{p\textsubscript{i}} nach ihrer aufsteigenden polaren Entfernung von der Nulllinie. Die Abbildung \ref{vector_graph} dient zur Visualisierung der Methode zur Ausrechnung von $\theta_i$. Die Eigenvektoren $\vec{u}$ und $\vec{v}$ bildeten das zweidimensionale Koordinatensystem, wobei $\vec{v}$ analog zu einer x-Achse agierte. Die Skalarprodukte \textit{d\textsubscript{i}\textsuperscript{u}} und \textit{d\textsubscript{i}\textsuperscript{v}} repräsentierten die parallelen Anteile des Vektors $\vec{{op}_i}$ der jeweiligen Eigenvektoren $\vec{u}$ und $\vec{v}$. Somit ließ sich der Winkel $\theta_i$ eines Punktes \textit{p\textsubscript{i}} zu der Nulllinie beziehungsweise dem Vektor $\vec{v}$ errechnen.

\begin{figure}[t]
	\includegraphics[scale=0.7]{Abbildungen/vector_graph.png}
	\centering
	\caption{Diese Abbildung stellt die Berechnung des Winkels $\theta_i$ graphisch dar}
	\label{vector_graph}
\end{figure}

Zusammenfassend wurde für jeden Punkt \textit{o} aus der Punktwolke eine RANSAC-Ebene \textit{E\textsubscript{N}} aus einer lokalen Nachbarschaften des Punktes mit \textit{K\textsubscript{1}} Punkten erstellt. Falls \textit{o} in der Ebene lag, und der größte Winkelabstand zwischen Punkten der Ebene mit \textit{o} als den Ursprung größer als $\frac{\pi}{2}$ betrug, wurde \textit{o} als ein Randpunkt markiert und gespeichert. Durch die Wiederholung dieser Schritte für alle Punkte wurden alle Randpunkte der Punktwolke identifiziert. Abbildung \ref{flow_chart} stellt den Programmablaufplan für dieses Verfahren dar. Die Probleme bei der Reproduktion dieses Verfahrens werden im Abschnitt \ref{label} besprochen.

\subsection{Verfahren zur Segmentierung Randpunkte}
Nachdem die Randpunkte der Punktwolke erkannt wurden, folgte die Segmentierung der Randpunkte zu Kanten. Hierbei wurden alle Randpunkte zusammen gruppiert, die zu einem geometrischen Merkmal des gescannten Objektes gehörten. Punkte wurden auf Basis zwei Kriterien segmentiert. Alle Punkte eines Segments sollten 