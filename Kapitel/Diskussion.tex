%Struktur:
% Erkenntnisse aus der Reproduktion
%PCL-Version und UBuntu
%Bounding Box mit Lasersensor
%Diskussion Test 1
%Diskussion Test 2
%Diskussion Test 3

\chapter{Diskussion}
\section{Zusammenfassung der Methodik und Ergebnisse}
Das in dieser Arbeit vorgelegte Verfahren wurde mit dem Hintergrund entwickelt, eine Methode zur Erkennung geometrischer Merkmale in wachsenden Punktwolken zu präsentieren. Dieses Verfahren sollte es ermöglichen, während der Erzeugung der Punktwolke relevante geometrische Informationen nebenbei bereitzustellen. Grundsätzlich sollte die sequenzielle Identifizierung der Geometrien eines Objektes während es Abtastung ermöglicht werden. Hierfür wurde zuerst das bereits vorhandene \textit{AGPN}-Verfahren nach \autocite{ni_edge_2016} aus der Literatur gewählt. Da das Programm des Verfahrens nicht durch die Autoren quelloffen zur Verfügung gestellt wurde, musste es durch den Verfasser implementiert werden. Das AGPN-Verfahren bestand aus zwei Teile - die Kantenerkennung sowie die Kantensegmentierung. Bei der Kantenerkennung wurden zuerst die \textit{K\textsubscript{1}} nächsten Nachbarpunkte eines Punktes \textit{o} gesucht um eine Nachbarschaft \textit{N\textsubscript{o}} zu erstellen. Aus diese Nachbarschaft wurden mittels eines RANSAC-Verfahrens die Punkte ausgesucht, die auf der gleichen Ebene \textit{E\textsubscript{N\textsubscript{o}}} lagen. Falls \textit{o} zu dieser Ebene gehörte, wurden alle Inliers der Ebene \textit{E\textsubscript{N\textsubscript{o}}} weiterhin auf ihren Winkelabstand überprüft. Mittels des Verfahrens aus Abschnitt \ref{edge_detection_reprod} wurden die Winkelabstände \textit{G\textsubscript{$\theta$}} von zwei konsekutiven Nachbarpunkten berechnet. Danach wurde es überprüft, ob der maximale Wert von \textit{G\textsubscript{$\theta$}} einen Schwellwert \textit{$\alpha$} überstieg. Falls dieses zutraf, wurde \textit{o} als einen Randpunkt markiert, der zu einer Kante gehörte. Diese Schritte wurden in einer Funktion namens \textit{FindEdgePoints} verpackt. 

Nach der Implementierung der Kantenerkennung wurde die Kantensegmentierung implementiert. Hierfür wurden zwei Methoden \textit{ComputeVectors} und \textit{ApplyRegionGrowing} entworfen. Die erste Methode kümmerte sich um die Bestimmung von den exakten benachbarten Randpunkte eines Randpunktes \textit{p} sowie die Bestimmung des Richtungsvektors von \textit{p}. Ähnlich wie bei \textit{FindEdgePoints} wurden mittels eines KD-Trees \textit{K\textsubscript{2}} benachbarten Randpunkte von \textit{p} bestimmt. Danach wurde mittels des RANSAC-Verfahrens eine Linie \textit{L\textsubscript{N\textsubscript{p}}} solange auf die Nachbarschaft \textit{N\textsubscript{p}} von \textit{p} angepasst, bis \textit{p} zu den Inliers von \textit{L\textsubscript{N\textsubscript{p}}} gehörte. Diese Inliers wurden als die exakten Nachbarpunkte von \textit{p} aufgespeichert. Die Linie \textit{L\textsubscript{N\textsubscript{p}}} wurde als Richtungsvektor von \textit{p} verwendet. Dieses wurde für alle erkannten Randpunkte wiederholt. Danach wurden die Randpunkte segmentiert. Hierfür wurde für einen unsegmentierten Randpunkt - der initialer Seedpunkt \textit{s\textsubscript{i}} ein neues Segment \textit{C} mit einem eindeutigen Kennzeichen erzeugt. Danach wurden die exakten Nachbarpunkte von \textit{s\textsubscript{i}} in der Methode \textit{GrowSegment} darauf geprüft, ob ihren Richtungsvektor mit dem von \textit{s\textsubscript{i}} übereinstimmte. Falls der Winkelabstand zwischen den beiden Richtungsvektoren kleiner als einen Schwellwert \textit{$\phi$} betrug, wurde der Nachbarpunkt zum \textit{C} hinzugefügt und als segmentiert markiert. Der übereinstimmende Nachbarpunkt wurde danach zu einer Sammlung nächster Seedpunkte \textit{s\textsubscript{c}} für \textit{C} hinzugefügt. Nachdem alle exakten Nachbarpunkte von \textit{s\textsubscript{i}} überprüft wurden, wurde das gleiche für die nächsten Seedpunkte \textit{s\textsubscript{c}} wiederholt, bis keine Punkte zum \textit{C} hinzugefügt werden konnten. Danach wurde ein neues Segment mit einem neuen initialen Seedpunkt erzeugt.

Nach der Reproduktion des AGPNs wurde das Verfahren für den Zweck dieser Arbeit erweitert. Zur Behebung der Anomalie der falschen Kanten wurden zwei Methoden präsentiert. Die erste Methode verwendete ein Bounding-Box, um die Randbereiche einer Iteration zu erkennen und gezielt die falschen Randpunkte aus diesen Bereichen zu entfernen. Die zweite Methode verwendete die Reihenfolge der empfangenen Punkte, um falschen Ränder zu erkennen und zu entfernen. Es wurden eine bestimmte Anzahl an Scan-Linien wahlweise am Anfang und/oder am Ende einer Iteration hierfür verwendet. Falls Punkte aus dieser Scan-Linien durch \textit{FindEdgePoints} als Randpunkte erkannt wurden, wurden diese entfernt. Die zweite Methode wies eine deutlich geringere Zeitkomplexität als die erste Methode auf, da es bei der ersten Methode um eine Matrizenrechnung handelte, während es bei der zweiten Methode um einfache Such- und Zugriffsoperationen handelte. Es wurden auch zusätzliche Filterverfahren wie \textit{UniformSampling} und \textit{StatisticalOutlierRemoval} implementiert, um die Anzahl der Punkte zu verringern, den Punkteabstand zu vereinheitlichen, sowie Ausreißer zu entfernen. Neben dieser Filterverfahren wurden auch Methoden implementiert, die das Verhältnis zwischen der Punkteindizes der Punkte vor und nach dem Filtern gemerkt haben. Dieses war insbesondere für die Korrektur der zu entfernenden Punkteindizes sowie der \textit{k} wiederholten Punkte wichtig. Die Methode \textit{FindEdgePoints} hat keine großen Änderungen erfahren. Als neue Funktionalität wurde die zweite Methode zur Entfernung falscher Kanten hier implementiert. Im Gegensatz dazu erfolgten die größten Änderungen in den zwei Verfahren von \textit{SegmentEdges}. Bei \textit{ComputeVectors} wurden in jeder Iteration die \textit{k} wiederholten der vorigen Iteration gefunden und die exakten Nachbarpunkte neu bestimmt, um die neuen Randpunkte aus der Randbereiche einzuschließen. Auch der Richtungsvektor dieser Punkte wurde neu berechnet. Bei \textit{ApplyRegionGrowing} wurden diese wiederholten Randpunkte gefunden und ihre Segment-Markierung zurückgesetzt. Daneben wurden auch die Markierungen der exakten Nachbarpunkte dieser wiederholten Randpunkte zurückgesetzt. Danach wurde die Methode \textit{GrowSegment} hier wiederverwendet, um das ursprüngliche Segment des wiederholten Randpunktes mit neuen Punkten zu erweitern. Nachdem alle vorhandenen Segmente um neue Punkte erweitert wurden, wurde als nächstes überprüft, ob noch unmarkierte Punkte vorhanden sind. In diesem Fall wurden anhand dieser Punkte neue Segmente erstellt, bis alle Randpunkte der neuen Iteration zu einem Segment hinzugefügt wurden. Somit wurden alle nötigen Methoden entwickelt, um ein erstes Prototyp für die Kantenerkennung und Kantensegmentierung wachsender Punktwolken zu entwerfen.

Um die Genauigkeit und Einsetzbarkeit des in dieser Arbeit entwickelten Verfahrens zu überprüfen, wurden auf Basis der Forschungsfrage sowie der Teilforschungsfragen drei Test konzipiert. Für diesen Tests wurden entweder reeller Aufnahmen von Bauteilen oder eine künstlich erzeugte Punktwolke - ein Ground-Truth - verwendet. Zur Auswertung der Genauigkeit der Verfahren wurden die Metriken nach \autocite[13]{ni_edge_2016} verwendet. Bei dem ersten Test wurde die Genauigkeit des IEFD-Verfahrens mit der des AGPN-Verdahrens überprüft. Hierfür wurde es anhand der Metriken ausgewertet, zu welchem Anteil alle Kanten der Testdatei richtig erkannt und vollständig segmentiert wurden. Es wurden für beiden Verfahren die gleichen Parameter verwendet. Das IEFD-Verfahren schnitt im Durchschnitt besser als das AGPN-Verfahren ab. Während das AGPN-Verfahren nur die Seitenrändern der Testdatei erkennen konnte, wurde durch das IEFD-Verfshren neben den Seitenrändern auch die Innen- und Außenkante erkannt. Die Segmentierung der erkannten Kanten erfolgte in beiden Verfahren sehr gut. Während das IEFD-Verfahren bis auf einen Testdurchlauf alle Kanten vollständig segmentiert hatte, konnte das AGPN-Verfahren alle erkannten Kanten in allen Testdurchläufen vollständig segmentieren. Bei dem zweiten Test wurde die Einfluss der Punktedichte auf die Genauigkeit des Verfahrens überprüft. Hierbei wurden unterschiedliche Iterationen der Testdatei bei konstanten Dimensionen und variablen Punkteabständen erstellt. Der Punkteabstand wurde zwischen 0,00005m und 0,005m variiert. Bis zu einem Punkteabstand von 0,0025m blieb die Genauigkeit des IEFD-Verfahrens sehr hoch und lieferte sowohl für die Kantenerkennung als auch für die Kantensegmentierung gute Ergebnisse. Bei einem Punkteabstand von 0,005m stieg die Genauigkeit des Verfahrens deutlich ab. Ausnahmsweise wurden bei der niedrigsten Punkteabstand beziehungsweise die höchste Punktedichte die Innen- und Außenkante der Testdatei nicht erkannt. Beim dritten Test wurde die Robustheit des Verfahrens überprüft. Hierzu wurden zwei Untersuchungen durchgeführt. Bei der ersten Untersuchung wurde eine zufällige Verzerrung einer bestimmten Amplitude zu der Punktwolke eingeführt. Damit wurde eine Störung des regelmäßigen Punktemusters erzielt. Die Amplitude der Verzerrung wurde zwischen 0,1 und 1,5 variiert. Bis zu einer Amplitude von 0,8 wurde keine Beeinträchtigung der Leistung des Verfahrens beobachtet. Es wurden perfekte Ergebnisse für die Genauigkeit des Verfahrens erzielt. Auch bis zu einer Amplitude von 1,0 wurde für die Kantenerkennung sehr gute Ergebnisse beobachtet. Im Gegensatz dazu sind die Ergebnisse der Kantensegmentierung relativ schlechter gewesen. Bei der höheren Amplituden wurden auch teilweise die falschen Kanten zwischen einzelner Iterationen nicht vollständig entfernt und haben die Kantensegmentierung gestört. Demzufolge sind die Ergebnisse der Kantensegmentierung bei einer Erhöhung der Verzerrung schlechter geworden. Dieser Trend wurde bis zu einer Amplitude von 1,3 beobachtet, bis beide Metriken für die Kantensegmentierung gegen einen Wert von 0,4 beziehungsweise 0,34 eingependelt sind. Die Kantenerkennung lieferte im Gegensatz dazu deutlich bessere Ergebnisse. Es wurden alle Seitenränder sowie die Innen- und Außenkante richtig erkannt.
Nur 


%TODO: Summerize results.
%Auf einem Ryzen 5 3600 Prozessor \autocite{noauthor_amd_2022} mit sechs Kernen und 12 Threads und einer Basistaktrate von 3,6 GHz kann eine siebenfache Leistungsverbesserung beobachtet werden. Eine Punktwolke mit ca. 450.000 Punkte könnte innerhalb 162 Sekunden verarbeitet werden. Nach der Parallelisierung erfolgte die Kantenerkennung innerhalb 22,5 Sekunden. Es ließ sich postulieren, dass Kanten durch die Verwendung eines Prozessors mit mehr Kernen noch schneller erkannt werden könnten. Die Verwendung eines Grafikprozessors, die deutlich mehr Kernen besitzen, hätte die Leistung der Kantenerkennung für sehr großen Punktwolken enorm steigern können. Allerdings, durfte diese aufgrund der Software-Voraussetzungen in Abschnitt \ref{soft_voraus} nicht an einem Grafikprozessor delegiert werden.  SOLL IN DISKUSSION KOMMEN