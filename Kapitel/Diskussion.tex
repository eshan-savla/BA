%Struktur:
% Zusammenfassung Methodik und Ergebnisse
% Erkenntnisse
%PCL-Version und UBuntu
%Bounding Box mit Lasersensor

\chapter{Diskussion}
\section{Zusammenfassung der Methodik und Ergebnisse}
Das in dieser Arbeit vorgelegte Verfahren wurde mit dem Hintergrund entwickelt, eine Methode zur Erkennung geometrischer Merkmale in wachsenden Punktwolken zu präsentieren. Dieses Verfahren sollte es ermöglichen, während der Erzeugung der Punktwolke relevante geometrische Informationen nebenbei bereitzustellen. Grundsätzlich sollte die sequenzielle Identifizierung der Geometrien eines Objektes während es Abtastung ermöglicht werden. Hierfür wurde zuerst das bereits vorhandene \textit{AGPN}-Verfahren nach \autocite{ni_edge_2016} aus der Literatur gewählt. Da das Programm des Verfahrens nicht durch die Autoren quelloffen zur Verfügung gestellt wurde, musste es durch den Verfasser implementiert werden. Das AGPN-Verfahren bestand aus zwei Teile - die Kantenerkennung sowie die Kantensegmentierung. Bei der Kantenerkennung wurden zuerst die \textit{K\textsubscript{1}} nächsten Nachbarpunkte eines Punktes \textit{o} gesucht um eine Nachbarschaft \textit{N\textsubscript{o}} zu erstellen. Aus diese Nachbarschaft wurden mittels eines RANSAC-Verfahrens die Punkte ausgesucht, die auf der gleichen Ebene \textit{E\textsubscript{N\textsubscript{o}}} lagen. Falls \textit{o} zu dieser Ebene gehörte, wurden alle Inliers der Ebene \textit{E\textsubscript{N\textsubscript{o}}} weiterhin auf ihren Winkelabstand überprüft. Mittels des Verfahrens aus Abschnitt \ref{edge_detection_reprod} wurden die Winkelabstände \textit{G\textsubscript{$\theta$}} von zwei konsekutiven Nachbarpunkten berechnet. Danach wurde es überprüft, ob der maximale Wert von \textit{G\textsubscript{$\theta$}} einen Schwellwert \textit{$\alpha$} überstieg. Falls dieses zutraf, wurde \textit{o} als einen Randpunkt markiert, der zu einer Kante gehörte. Diese Schritte wurden in einer Funktion namens \textit{FindEdgePoints} verpackt. 

Nach der Implementierung der Kantenerkennung wurde die Kantensegmentierung implementiert. Hierfür wurden zwei Methoden \textit{ComputeVectors} und \textit{ApplyRegionGrowing} entworfen. Die erste Methode kümmerte sich um die Bestimmung von den exakten benachbarten Randpunkte eines Randpunktes \textit{p} sowie die Bestimmung des Richtungsvektors von \textit{p}. Ähnlich wie bei \textit{FindEdgePoints} wurden mittels eines KD-Trees \textit{K\textsubscript{2}} benachbarten Randpunkte von \textit{p} bestimmt. Danach wurde mittels des RANSAC-Verfahrens eine Linie \textit{L\textsubscript{N\textsubscript{p}}} solange auf die Nachbarschaft \textit{N\textsubscript{p}} von \textit{p} angepasst, bis \textit{p} zu den Inliers von \textit{L\textsubscript{N\textsubscript{p}}} gehörte. Diese Inliers wurden als die exakten Nachbarpunkte von \textit{p} aufgespeichert. Die Linie \textit{L\textsubscript{N\textsubscript{p}}} wurde als Richtungsvektor von \textit{p} verwendet. Dieses wurde für alle erkannten Randpunkte wiederholt. Danach wurden die Randpunkte segmentiert. Hierfür wurde für einen unsegmentierten Randpunkt - der initialer Seedpunkt \textit{s\textsubscript{i}} ein neues Segment \textit{C} mit einem eindeutigen Kennzeichen erzeugt. Danach wurden die exakten Nachbarpunkte von \textit{s\textsubscript{i}} in der Methode \textit{GrowSegment} darauf geprüft, ob ihren Richtungsvektor mit dem von \textit{s\textsubscript{i}} übereinstimmte. Falls der Winkelabstand zwischen den beiden Richtungsvektoren kleiner als einen Schwellwert \textit{$\phi$} betrug, wurde der Nachbarpunkt zum \textit{C} hinzugefügt und als segmentiert markiert. Der übereinstimmende Nachbarpunkt wurde danach zu einer Sammlung nächster Seedpunkte \textit{s\textsubscript{c}} für \textit{C} hinzugefügt. Nachdem alle exakten Nachbarpunkte von \textit{s\textsubscript{i}} überprüft wurden, wurde das gleiche für die nächsten Seedpunkte \textit{s\textsubscript{c}} wiederholt, bis keine Punkte zum \textit{C} hinzugefügt werden konnten. Danach wurde ein neues Segment mit einem neuen initialen Seedpunkt erzeugt.

Nach der Reproduktion des AGPNs wurde das Verfahren für den Zweck dieser Arbeit erweitert. Zur Behebung der Anomalie der falschen Kanten wurden zwei Methoden präsentiert. Die erste Methode verwendete ein Bounding-Box, um die Randbereiche einer Iteration zu erkennen und gezielt die falschen Randpunkte aus diesen Bereichen zu entfernen. Die zweite Methode verwendete die Reihenfolge der empfangenen Punkte, um falschen Ränder zu erkennen und zu entfernen. Es wurden eine bestimmte Anzahl an Scan-Linien wahlweise am Anfang und/oder am Ende einer Iteration hierfür verwendet. Falls Punkte aus dieser Scan-Linien durch \textit{FindEdgePoints} als Randpunkte erkannt wurden, wurden diese entfernt. Die zweite Methode wies eine deutlich geringere Zeitkomplexität als die erste Methode auf, da es bei der ersten Methode um eine Matrizenrechnung handelte, während es bei der zweiten Methode um einfache Such- und Zugriffsoperationen handelte. Es wurden auch zusätzliche Filterverfahren wie \textit{UniformSampling} und \textit{StatisticalOutlierRemoval} implementiert, um die Anzahl der Punkte zu verringern, den Punkteabstand zu vereinheitlichen, sowie Ausreißer zu entfernen. Neben dieser Filterverfahren wurden auch Methoden implementiert, die das Verhältnis zwischen der Punkteindizes der Punkte vor und nach dem Filtern gemerkt haben. Dieses war insbesondere für die Korrektur der zu entfernenden Punkteindizes sowie der \textit{k} wiederholten Punkte wichtig. Die Methode \textit{FindEdgePoints} hat keine großen Änderungen erfahren. Als neue Funktionalität wurde die zweite Methode zur Entfernung falscher Kanten hier implementiert. Im Gegensatz dazu erfolgten die größten Änderungen in den zwei Verfahren von \textit{SegmentEdges}. Bei \textit{ComputeVectors} wurden in jeder Iteration die \textit{k} wiederholten der vorigen Iteration gefunden und die exakten Nachbarpunkte neu bestimmt, um die neuen Randpunkte aus der Randbereiche einzuschließen. Auch der Richtungsvektor dieser Punkte wurde neu berechnet. Bei \textit{ApplyRegionGrowing} wurden diese wiederholten Randpunkte gefunden und ihre Segment-Markierung zurückgesetzt. Daneben wurden auch die Markierungen der exakten Nachbarpunkte dieser wiederholten Randpunkte zurückgesetzt. Danach wurde die Methode \textit{GrowSegment} hier wiederverwendet, um das ursprüngliche Segment des wiederholten Randpunktes mit neuen Punkten zu erweitern. Nachdem alle vorhandenen Segmente um neue Punkte erweitert wurden, wurde als nächstes überprüft, ob noch unmarkierte Punkte vorhanden sind. In diesem Fall wurden anhand dieser Punkte neue Segmente erstellt, bis alle Randpunkte der neuen Iteration zu einem Segment hinzugefügt wurden. Somit wurden alle nötigen Methoden entwickelt, um ein erstes Prototyp für die Kantenerkennung und Kantensegmentierung wachsender Punktwolken zu entwerfen.

Um die Genauigkeit und Einsetzbarkeit des in dieser Arbeit entwickelten Verfahrens zu überprüfen, wurden auf Basis der Forschungsfrage sowie der Teilforschungsfragen drei Test konzipiert. Für diesen Tests wurden entweder reeller Aufnahmen von Bauteilen oder eine künstlich erzeugte Punktwolke - ein Ground-Truth - verwendet. Zur Auswertung der Genauigkeit der Verfahren wurden die Metriken nach \autocite[13]{ni_edge_2016} verwendet. Bei dem ersten Test wurde die Genauigkeit des IEFD-Verfahrens mit der des AGPN-Verdahrens überprüft. Hierfür wurde es anhand der Metriken ausgewertet, zu welchem Anteil alle Kanten der Testdatei richtig erkannt und vollständig segmentiert wurden. Es wurden für beiden Verfahren die gleichen Parameter verwendet. Das IEFD-Verfahren schnitt im Durchschnitt besser als das AGPN-Verfahren ab. Während das AGPN-Verfahren nur die Seitenrändern der Testdatei erkennen konnte, wurde durch das IEFD-Verfshren neben den Seitenrändern auch die Innen- und Außenkante erkannt. Die Segmentierung der erkannten Kanten erfolgte in beiden Verfahren sehr gut. Während das IEFD-Verfahren bis auf einen Testdurchlauf alle Kanten vollständig segmentiert hatte, konnte das AGPN-Verfahren alle erkannten Kanten in allen Testdurchläufen vollständig segmentieren. Bei dem zweiten Test wurde die Einfluss der Punktedichte auf die Genauigkeit des Verfahrens überprüft. Hierbe i wurden unterschiedliche Iterationen der Testdatei bei konstanten Dimensionen und variablen Punkteabständen erstellt. Der Punkteabstand wurde zwischen 0,00005m und 0,005m variiert. Bis zu einem Punkteabstand von 0,0025m blieb die Genauigkeit des IEFD-Verfahrens sehr hoch und lieferte sowohl für die Kantenerkennung als auch für die Kantensegmentierung gute Ergebnisse. Bei einem Punkteabstand von 0,005m stieg die Genauigkeit des Verfahrens deutlich ab. Ausnahmsweise wurden bei der niedrigsten Punkteabstand beziehungsweise die höchste Punktedichte die Innen- und Außenkante der Testdatei nicht erkannt. Beim dritten Test wurde die Robustheit des Verfahrens überprüft. Hierzu wurden zwei Untersuchungen durchgeführt. Bei der ersten Untersuchung wurde eine zufällige Verzerrung einer bestimmten Amplitude zu der Punktwolke eingeführt. Damit wurde eine Störung des regelmäßigen Punktemusters erzielt. Die Amplitude der Verzerrung wurde zwischen 0,1 und 1,5 variiert. Bis zu einer Amplitude von 0,8 wurde keine Beeinträchtigung der Leistung des Verfahrens beobachtet. Es wurden perfekte Ergebnisse für die Genauigkeit des Verfahrens erzielt. Auch bis zu einer Amplitude von 1,0 wurde für die Kantenerkennung sehr gute Ergebnisse beobachtet. Im Gegensatz dazu sind die Ergebnisse der Kantensegmentierung relativ schlechter gewesen. Bei der höheren Amplituden wurden auch teilweise die falschen Kanten zwischen einzelner Iterationen nicht vollständig entfernt und haben die Kantensegmentierung gestört. Demzufolge sind die Ergebnisse der Kantensegmentierung bei einer Erhöhung der Verzerrung schlechter geworden. Dieser Trend wurde bis zu einer Amplitude von 1,3 beobachtet, bis beide Metriken für die Kantensegmentierung gegen einen Wert von 0,4 beziehungsweise 0,34 eingependelt sind. Die Kantenerkennung lieferte im Gegensatz dazu deutlich bessere Ergebnisse. Es wurden alle Seitenränder sowie die Innen- und Außenkante richtig erkannt. Ab einer Amplitude von 0,9 wurden die Spuren falscher Kanten zwischen Iterationen auch erkannt. Diese Anzahl stieg bis zu einer Amplitude von 1,3 auf, bevor sie wieder leicht herunterstieg. Ab einer Amplitude von 1,3 konnten falsche Kanten weniger deutlich erkannt werden. Bei der zweiten Untersuchung des dritten Tests wurde die Genauigkeit des Verfahrens bei Anwendung auf vier Punktwolken reeller Bauteile überprüft. Es wurden hierfür Bauteile mit unterschiedlichen geometrischen Merkmalen wie Löcher, kreisförmige sowie rechteckige Aussparungen, Nuten und Innenkanten verwendet. Für alle vier Bauteile wurden gute bis sehr gute Ergebnisse für die Kantenerkennung sowie die Kantensegmentierung bemerkt. Die Seitenränder, Innenkante und Aussparungen der Bauteile wurden immer richtig erkannt. Die Erkennung aller Kanten der Nuten sowie der Löcher erfolgte gegenteilig nicht immer akkurat. Die Kantensegmentierung der Seitenränder, Innenkanten und der Aussparungen erfolgte in den überwiegenden Fällen richtig. Manchmal wurden diese Kanten nicht vollständig segmentiert, sondern wurden zusätzliche Segmente erzeugt. Die Kanten der Nuten mit einer höheren Anzahl an Störpunkte konnten durch das Verfahren nicht vollständig segmentiert werden. Auch die kreisförmigen Löcher stellten eine Hürde für die Kantensegmentierung dar. 

Bei der Konzipierung des Verfahrens sowie bei der Auswertung der Testergebnisse sind viele Einzelheiten zur Erkenntnis gekommen. Bei diesen Erkenntnissen handelte es sich unter anderem um Anmerkungen zu der Leistungsfähigkeit des Verfahrens sowie mögliche Erklärungen der Ergebnisse

\section{Erkenntnisse aus der Methodik und Ergebnisse}

Die wichtigste Anmerkung zu der Leistung und Rechenzeit des Verfahrens erfolgte bei der Parallelisierung der \textit{FindEdgePoints}-Methode. Auf einem Ryzen 5 3600 Prozessor \autocite{noauthor_amd_2022} mit sechs Kernen und 12 Threads und einer Basistaktrate von 3,6 GHz wurde eine siebenfache Leistungsverbesserung beobachtet. Eine Punktwolke mit ca. 450.000 Punkte konnte vor der Parallelisierung innerhalb 162 Sekunden verarbeitet werden. Nach der Parallelisierung erfolgte die Kantenerkennung innerhalb 22,5 Sekunden. Es ließ sich postulieren, dass Kanten durch die Verwendung eines Prozessors mit mehr Kernen noch schneller erkannt werden könnten. Die Verwendung eines Grafikprozessors, die deutlich mehr Kernen besitzen, hätte die Leistung der Kantenerkennung für sehr großen Punktwolken enorm steigern können. Hierzu hätte sich ein Grafikprozessor mit tausenden Kernen die Verarbeitung und Kantenerkennung von Punktwolken erheblich steigern können. Allerdings, durfte diese aufgrund der Software-Voraussetzungen in Abschnitt \ref{soft_voraus} nicht gemacht werden.

Die zweite Erkenntnis bei der Reproduktion des AGPN Verfahrens ist für die Implementierung auf einem Linux-basierten System relevant. Die Kantenerkennung erfolgte auf die neuere Version des Betriebssystems - Ubuntu Jammy Jellyfish (Version 22.04) - reibungslos und lieferte sehr gute Ergebnisse. Die Wiederholung des Programms auf eine ältere Generation des Betriebssystems - Ubuntu Focal Fossa (Version 20.04) - lieferte im Gegensatz schlechtere Ergebnisse. Ein Fehler seitens der Hardware wurde ausgeschlossen, indem der gleiche Rechner mit konstanten Spezifikationen für beide Betriebssysteme verwendet wurde. Auch der Einfluss fremder Software auf dem Programm wurde ausgeschlossen, indem das Programm an Betriebssysteme nur mit den notwendigen Softwareabhängigkeiten ausführt wurde. Eine genauere Untersuchung lieferte den Hinweis, dass die Standardversion der PCL-Bibliothek für beide Betriebssysteme unterschiedlich war. Die PCL-Bibliotheksversion 1.10 wurde Standardweise mit Ubuntu Focal Fossa geliefert, wobei die Version 1.12 Standardweise mit Ubuntu Jammy Jellyfish geliefert wurde. Das Downsampling-Verfahren aus der Bibliotheksversion 1.10 konnte sehr dichte Punktwolken nicht korrekt verarbeiten. Dieses Fehler wurde allerdings in der neueren Version der Bibliothek behoben. Aus diesem Grund lässt es sich empfehlen, entweder die Ubuntu Version 22.04 zu verwenden oder die Standardversion der PCL-Bibliothek zu entfernen und stattdessen die Version 1.12 zu installieren. Abbildung \ref{fig: pcl_version_comparision} zeigt die Randpunke und im weiteren Sinne die Kanten, die nach dem fehlerhaften Downsampling erkannt wurden.


\begin{figure}[t]
	\centering
	\begin{subfigure}[h]{0.49\textwidth}
		\includegraphics[width=\textwidth]{Abbildungen/blech_edges.png}
		\centering
		\caption{Randpunkte mit PCL 1.12}
		\label{fig: blech_edges}
	\end{subfigure}
	\hfill
	\begin{subfigure}[h]{0.49\textwidth}
		\includegraphics[width=\textwidth]{Abbildungen/blech_bad_edges.png}
		\centering
		\caption{Randpunkte mit PCL 1.10}
		\label{fig: bad_edges}
	\end{subfigure}
	\caption{Randpunkte, die durch beider Versionen von PCL erkannt werden}
	\label{fig: pcl_version_comparision}
\end{figure}

Während der Entwicklung der Methoden aus Abschnitt \ref{false_edges} zur Entfernung falscher Kanten zwischen zwei Iterationen wurden Anmerkungen zu der Leistung und Genauigkeit der ersten Methode gemacht. Obwohl dieses Verfahren theoretisch funktionieren hat, lieferte es unzureichende Ergebnisse. Die Ungenauigkeit des Bounding-Boxes wurde durch die sehr hohe Dichte der Punktwolke beziehungsweise den sehr kurzen Abstand zwischen Punkten amplifiziert. Bei einem mittleren Punktabstand von weniger als 0,1 mm führte die inhärente Ungenauigkeit des Bounding-Boxes dazu, dass übermäßig viele Randpunkte entfernt wurden. Darüber hinaus kosteten die Transformation der Punktwolke und weiteren Berechnungen zusätzliche Rechenleistung und eigneten sich zu zeitintensiven Operationen nicht, weil sie eine Zeitkomplexität deutlich höher als $O(n)$ aufwiesen. Deswegen wurde die zweite Methode zur Entfernung falscher Segmente bevorzugt. Bei der Konzipierung beider Methoden zur Entfernung falscher Kanten wurde nebenbei auch ein zusätzliches Konzept entworfen. Bei diesem Verfahren sollte die Position sowie das Koordinatensystem des Sensors während der Abtastung ausgenutzt werden. Es sollten ähnlich wie bei der ersten Methode zwei Regionen definiert werden, die alle falschen Kanten umfassen würden. Hierzu sollten die Positionen des Sensors am Anfang und am Ende jeder Iteration aufgespeichert werden, um die Positionen der falschen Randpunkte an den jeweiligen Seiten zu bestimmen. Das Koordinatensystem des Sensors wäre zur Orientierung der Regionen verwendet werden. Die x-Achse würde als Stützvektor der Tiefe, die y-Achse als Stützvektor der Breite und die z-Achse als Stützvektor der Höhe dienen. Die y-Achse des Sensors würde auch seinem Richtungsvektor entsprechen. Zur Dimensionierung der Regionen sollten die Sensorspezifikationen verwendet werden. Der Lasersensor aus Abschnitt \ref{test_data} dieser Arbeit kann 290 mm in der x-Richtung und 460 mm in der z-Richtung scannen. Auf diesen Werten wird ein zusätzlicher Puffer addiert, sodass die Regionen möglichst alle falschen Randpunkte umfassen würden. Der Ausmaß für die Breite dieser Regionen dürfte durch den Benutzer angegeben werden. Während der Konzipierung dieses Verfahrens wurde jedoch enthüllt, dass die Sensorposition nicht immer Vertikal über das Bauteil lag, sondern meistens abgesetzt und in einer anderen Orientierung zu ihm lag. Als Lösungsansatz könnten die Randpunkte nach dem Koordinatensystem des Sensors transformiert werden, allerdings hätte diese wiederholte Berechnung für jeden Randpunkt einer Iteration zu einer Zeitkomplexität deutlich über $O(n)$ sowie zu einer Verlangsamung des gesamten Verfahrens geführt. Deswegen wurde diese Methode zur Entfernung falschen Kanten nicht vervollständigt und diese Zeit zur Entwicklung der dritten Methode investiert. 

Das wichtigste Erkenntnis des ersten Tests ist die Bestätigung der ersten Hypothese. Das IEFD-Verfahren hat zu einer hohen Genauigkeit alle Kanten der Testdatei erkennt und segmentiert. Aufgrund der hohen Einheitlichkeit des Punkteabstandes, der gleichmäßigen Höhe aller Punkten einer Ebene sowie der klaren Trennung der Ebenen wurden alle Seitenränder und die Innen- sowie Außenkante vollständig erkannt und segmentiert. Allerdings ist das gleiche nicht für das AGPN-Verfahren geschehen. Trotz Verwendung der gleichen Testdatei hat das AGPN-Verfahren die Faltungen des Bauteils überhaupt nicht erkannt. Da alle Parameter beider Verfahren den gleichen Wert hatten und konstant gehalten wurden, lässt sich überlegen, ob die Anzahl der verarbeiteten Punkte einen Unterschied machen könnten. Während die Testdatei bei dem IEFD-Verfahren in kleineren Teilen zerlegt wurde, wurde bei dem AGPN-Verfahren die gesamte Punktwolke verarbeitet. Das Verhältnis zwischen der Anzahl der verarbeiteten Punkte und der Anzahl \textit{K\textsubscript{1}} an Nachbarpunkte ist somit für beide Verfahren unterschiedlich gewesen. Dieses Verhältnis ist für jede Iteration des IEFD-Verfahrens deutlich höher gewesen. Die Ergebnisse des AGPN-Verfahrens könnten durch die Wahl eines höheren Wertes für \textit{K\textsubscript{1}} verbessert werden. Die Ergebnisse des zweiten Tests haben die zweite Hypothese nicht bestätigt. Die Genauigkeit hat sich nicht proportional zu der Punktedichte verhält, sondern wurde kein Trend eindeutig erkannt. Der Verlauf der Genauigkeit wird einfach logarithmisch in Abbildung \ref{fig: point_density_trend} dargestellt und ertönt die Abwesenheit eines erkennbaren Trends. Je mehr der Punkteabstand erhöht wurde, desto weniger Punkte wurden in der Testdatei generiert. Die Ursache dieses Verhaltens sind die konstanten Dimensionen der Testdatei gewesen. Wie es auch in Abbildung \ref{fig: testdata_0,005m} zu sehen ist, ist die Erkennung geometrischer Merkmale der Testdatei schwerer geworden. Es lässt sich überlegen, ob die Genauigkeit des Verfahrens mit der Anzahl der Punkte statt der Punktedichte korreliert. Das obige Postulat aus dem ersten Test - das Verhältnis zwischen der Anzahl der verarbeiteten Punkte und \textit{K\textsubscript{1}} - würde die niedrigere Bewertung des Verfahrens bei einem sehr kürzen Punkteabstand von 0,00005m auch begründen. Bei diesem Punkteabstand wurden 48.000.000 Punkte in der Testdatei generiert, wodurch die Anzahl der zu verarbeitenden Punkte in jeder Iteration auch gestiegen ist. Dadurch hat wahrscheinlich der Wert für \textit{K\textit{1}} nicht gereicht, um die Innen- und Außenkante der Testdatei zu korrekt erkennen. Auch die Kantensegmentierung scheint von der Anzahl an Punkte abhängig zu sein. Es wurden bei den höheren Punkteabständen wenig Punkte wiederholt, welches die Erweiterung bestehender Segmente beeinträchtigt hat. Für den dritten Test lässt sich die allgemeine Aussage treffen, dass die dritte Hypothese bestätigt wurde. In beiden teilen der dritten Untersuchung konnte das IEFD-Verfahren zuverlässige und gute Ergebnisse liefern. Bis zu einer Amplitude von 1,0 der Verzerrung lieferte die Kantensegmentierung sehr gute Ergebnisse. Die Erzielung einer perfekten Bewertung wurde dadurch verhindert, dass die falschen Kanten zwischen Iterationen nicht deutlich und lückenlos erkannt wurden. Dies führte dazu, dass die Segmentierung dieser falschen Kanten unvollständig erfolgt hat. Auch die Anzahl der Störpunkte ist mit der Amplitude der Verzerrung gestiegen. Dieses hat dazu geführt, dass die Erweiterung der vorhandener Segmente dadurch gestört worden ist. Die Werte für die Metriken  \textit{p\textsubscript{dct}} und \textit{p\textsubscript{mjt}} scheinen bei der höheren Verzerrungen gegen einem Wert zwischen 0,34 und 0,40 zu tendieren. Dies könnte daran liegen, dass die falschen Kanten zwischen Iterationen ab einer Amplitude von 1,4 weniger deutlich zu erkennen waren. Gleichzeitig sind die Anzahl der Störpunkte auch gestiegen. Aufgrund des großen Verzerrungsfaktors sind kleine Lücken entstanden, wodurch die angrenzenden Punkte als Randpunkte markiert wurden und für die Kantensegmentierung als Störpunkte wirkten. Es könnte argumentiert werden, dass der durchschnittliche Punkteabstand ab einer Amplitude von 1,0 sich geändert hat. Eine Ermittlung dieses Wertes sowie die entsprechende Anpassung von \distthresha und \distthreshb hätte zu besseren Ergebnissen geführt. Der zweite Teil der dritten Untersuchung hat gezeigt, dass das IEFD-Verfahren gute Ergebnisse bei der Verarbeitung von Punktewolken reeller Bauteile liefert. Dank der Wahl eines geeigneten Wertes für \distthreshb konnten auch nahegelegene Kanten richtig und getrennt voneinander segmentiert werden. Das Verfahren ermöglicht die Unterscheidung zwischen geometrischen Merkmale eines feinen Grades. Allerdings hatte das Verfahren Schwierigkeiten bei der Erkennung und Segmentierung von kreisförmigen Löchern des Ablagetisches. Der Grund hierfür lag daran, dass die Kanten der Kreise von einem Seitenrand auf eine Faltung übergingen. Dieser Übergang ist in Abbildung \ref{label} abgebildet. Es lässt sich behaupten, dass die Kantenerkennung bei solchen Übergängen fehlschlägt, allerdings könnte diesem Verhalten durch die Anpassung der Prozessparameter entgegengewirkt werden. 

\begin{figure}[t]
	\includegraphics[width=0.85\textwidth]{Abbildungen/point_density_log_scale.png}
	\centering
	\caption{Der Verlauf der vier Metriken bei einem steigenden Punkteabstand}
	\label{fig: point_density_trend}
\end{figure}


%TODO: Finish insights from test 3 part 2 | Add pic of table hole and compare results with literature.