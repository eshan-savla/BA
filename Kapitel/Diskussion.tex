%Struktur:
% Zusammenfassung Methodik und Ergebnisse
% Erkenntnisse
%PCL-Version und UBuntu
%Bounding Box mit Lasersensor

\chapter{Diskussion} \label{diskussion}
\section{Zusammenfassung der Methodik und Ergebnisse}
Das in dieser Arbeit vorgelegte Verfahren wurde mit dem Hintergrund entwickelt, eine Methode zur Erkennung geometrischer Merkmale in wachsenden Punktwolken zu präsentieren. Dieses Verfahren sollte es ermöglichen, während der Erzeugung der Punktwolke relevante geometrische Informationen nebenbei bereitzustellen. Grundsätzlich sollte die sequenzielle Identifizierung der Geometrien eines Objektes während es Abtastung ermöglicht werden. Hierfür wurde zuerst das bereits vorhandene \textit{AGPN}-Verfahren nach \autocite{ni_edge_2016} aus der Literatur gewählt. Da das Programm des Verfahrens nicht durch die Autoren quelloffen zur Verfügung gestellt wurde, musste es durch den Verfasser implementiert werden. Das AGPN-Verfahren bestand aus zwei Komponenten - die Kantenerkennung sowie die Kantensegmentierung. Bei der Kantenerkennung wurden zuerst die \textit{K\textsubscript{1}} nächsten Nachbarpunkte eines Punktes \textit{o} gesucht um eine Nachbarschaft \textit{N\textsubscript{o}} zu erstellen. Aus dieser Nachbarschaft wurden mittels eines RANSAC-Verfahrens die Punkte ausgesucht, die auf der gleichen Ebene \textit{E\textsubscript{N\textsubscript{o}}} lagen. Falls \textit{o} zu dieser Ebene gehörte, wurden alle Inliers der Ebene \textit{E\textsubscript{N\textsubscript{o}}} weiterhin auf ihren Winkelabstand überprüft. Mittels des Verfahrens aus Abschnitt~\ref{edge_detection_reprod} wurden die Winkelabstände \textit{G\textsubscript{$\theta$}} von zwei konsekutiven Nachbarpunkten berechnet. Danach wurde überprüft, ob der maximale Wert von \textit{G\textsubscript{$\theta$}} einen Schwellwert \textit{$\alpha$} überstieg. Falls dies zutraf, wurde \textit{o} als ein Randpunkt markiert, der zu einer Kante gehörte. Diese Schritte wurden in einer Funktion namens \textit{\hyperref[alg:find_edge_points]{FindEdgePoints}} verpackt. 

Nach der Implementierung der Kantenerkennung wurde die Kantensegmentierung implementiert. Hierfür wurden zwei Methoden \textit{\hyperref[alg:compute_vectors]{ComputeVectors}} und \textit{\hyperref[alg:apply_region_growing]{ApplyRegionGrowing}} entworfen. Die erste Methode kümmerte sich um die Bestimmung von den exakten benachbarten Randpunkte eines Randpunktes \textit{p} sowie die Bestimmung des Richtungsvektors von \textit{p}. Ähnlich wie bei \textit{\hyperref[alg:find_edge_points]{FindEdgePoints}} wurden mittels eines KD-Trees \textit{K\textsubscript{2}} benachbarten Randpunkte von \textit{p} bestimmt. Danach wurde mittels des RANSAC-Verfahrens eine Linie \textit{L\textsubscript{N\textsubscript{p}}} solange auf die Nachbarschaft \textit{N\textsubscript{p}} von \textit{p} angepasst, bis \textit{p} zu den Inliers von \textit{L\textsubscript{N\textsubscript{p}}} gehört. Diese Inliers wurden als die exakten Nachbarpunkte von \textit{p} aufgespeichert. Die Linie \textit{L\textsubscript{N\textsubscript{p}}} wurde als Richtungsvektor von \textit{p} verwendet. Dieses wurde für alle erkannten Randpunkte wiederholt. Danach wurden die Randpunkte segmentiert. Hierfür wurde für einen unsegmentierten Randpunkt - der initialer Seedpunkt \textit{s\textsubscript{i}} ein neues Segment \textit{C} mit einem eindeutigen Kennzeichen erzeugt. Danach wurden die exakten Nachbarpunkte von \textit{s\textsubscript{i}} in der Methode \textit{\hyperref[alg:grow_segment]{GrowSegment}} darauf geprüft, ob ihren Richtungsvektor mit dem von \textit{s\textsubscript{i}} übereinstimmte. Falls der Winkelabstand zwischen den beiden Richtungsvektoren kleiner als der Schwellwert \textit{$\phi$} ist, wurde der Nachbarpunkt zum Segment \textit{C} hinzugefügt und als segmentiert markiert. Der übereinstimmende Nachbarpunkt wurde danach zu einer Sammlung nächster Seedpunkte \textit{s\textsubscript{c}} für Segment \textit{C} hinzugefügt. Nachdem alle exakten Nachbarpunkte von \textit{s\textsubscript{i}} überprüft wurden, wurde das gleiche für die nächsten Seedpunkte \textit{s\textsubscript{c}} wiederholt, bis keine Punkte zum Segment \textit{C} hinzugefügt werden konnten. Danach wurde ein neues Segment mit einem neuen initialen Seedpunkt erzeugt.

Nach der Reproduktion des AGPNs wurde das Verfahren für den Zweck dieser Arbeit erweitert. Zur Behebung der Anomalie der falschen Kanten wurden zwei Methoden präsentiert. Die erste Methode verwendete eine \textit{Bounding-Box}, um die Randbereiche einer Iteration zu erkennen und gezielt die falschen Randpunkte aus diesen Bereichen zu entfernen. Die zweite Methode verwendete die Reihenfolge der empfangenen Punkte, um falschen Ränder zu erkennen und zu entfernen. Es wurde eine bestimmte Anzahl an Scan-Linien wahlweise am Anfang und/oder am Ende einer Iteration hierfür verwendet. Falls Punkte aus diesen Scan-Linien durch \textit{\hyperref[alg:find_edge_points]{FindEdgePoints}} als Randpunkte erkannt wurden, wurden diese entfernt. Die zweite Methode wies eine deutlich geringere Zeitkomplexität als die erste Methode auf, da es bei der ersten Methode um eine Matrizenrechnung handelte, während es bei der zweiten Methode um einfache Such- und Zugriffsoperationen handelte. Es wurden auch zusätzliche Filterverfahren wie \textit{UniformSampling} und \textit{StatisticalOutlierRemoval} \autocite{rusu_3d_2011} \autocite{rusu_towards_2008} implementiert, um die Anzahl der Punkte zu verringern, den Punkteabstand zu vereinheitlichen, sowie Ausreißer zu entfernen. Neben dieser Filterverfahren wurden auch Methoden implementiert, die das Verhältnis zwischen der Punkteindizes der Punkte vor und nach dem Filtern gemerkt haben. Dieses war insbesondere für die Korrektur der zu entfernenden Punkteindizes sowie der \textit{k} wiederholten Punkte wichtig. Die Methode \textit{\hyperref[alg:find_edge_points]{FindEdgePoints}} hat keine großen Änderungen erfahren. Als neue Funktionalität wurde die zweite Methode zur Entfernung falscher Kanten hier implementiert. Im Gegensatz dazu erfolgten die größten Änderungen in den zwei Verfahren von \textit{SegmentEdges}. Bei \textit{\hyperref[alg:compute_vectors]{ComputeVectors}} wurden in jeder Iteration die \textit{k} wiederholten Scan-Linien der vorigen Iteration wiederverwendet und die exakten Nachbarpunkte neu bestimmt, um die neuen Randpunkte aus den Randbereichen einzuschließen. Auch der Richtungsvektor dieser Punkte wurde neu berechnet. Bei \textit{\hyperref[alg:apply_region_growing]{ApplyRegionGrowing}} wurden diese wiederholten Randpunkte gefunden und ihre Segment-Markierung zurückgesetzt. Daneben wurden auch die Markierungen der exakten Nachbarpunkte dieser wiederholten Randpunkte zurückgesetzt. Danach wurde die Methode \textit{\hyperref[alg:grow_segment]{GrowSegment}} hier wiederverwendet, um das ursprüngliche Segment des wiederholten Randpunktes mit neuen Punkten zu erweitern. Nachdem alle vorhandenen Segmente um neue Punkte erweitert wurden, wurde als nächstes überprüft, ob noch unmarkierte Punkte vorhanden sind. In diesem Fall wurden anhand dieser Punkte neue Segmente erstellt, bis alle Randpunkte der neuen Iteration zu einem Segment hinzugefügt wurden. Somit wurden alle nötigen Methoden entwickelt, um einen ersten Prototyp für die Kantenerkennung und Kantensegmentierung wachsender Punktwolken zu entwerfen.

Um die Genauigkeit und Einsetzbarkeit des in dieser Arbeit entwickelten Verfahrens zu überprüfen, wurden auf Basis der Forschungsfrage sowie der Teilforschungsfragen drei Test konzipiert. Für diesen Tests wurden entweder reeller Aufnahmen von Bauteilen oder eine synthetische Punktwolke - ein Ground-Truth - verwendet. Zur Auswertung der Genauigkeit der Verfahren wurden die Metriken nach \autocite[13]{ni_edge_2016} verwendet. Bei dem ersten Test wurde die Genauigkeit des IEFD-Verfahrens mit der des AGPN-Verfahrens überprüft. Hierfür wurden die vorgestellten Metriken in Abschnitt~\ref{evaluations_metrics} herangezogen um den Anteil aller richtig erkannten und vollständig segmentierten Kanten der Testdatei zu bestimmen. Es wurden für beide Verfahren die gleichen Parameter verwendet. Das IEFD-Verfahren schnitt im Durchschnitt besser als das AGPN-Verfahren ab. Während das AGPN-Verfahren nur die Seitenrändern der Testdatei erkennen konnte, wurde durch das IEFD-Verfshren neben den Seitenrändern auch die Innen- und Außenkante erkannt. Die Segmentierung der erkannten Kanten lieferte in beiden Verfahren gute bis sehr gute Ergebnisse. Während das IEFD-Verfahren bis auf einen Testdurchlauf alle Kanten vollständig segmentiert hatte, konnte das AGPN-Verfahren alle erkannten Kanten in allen Testdurchläufen vollständig segmentieren. Bei dem zweiten Test wurde die Einfluss der Punktedichte auf die Genauigkeit des Verfahrens überprüft. Hierbei wurden unterschiedliche Iterationen der Testdatei bei konstanten Dimensionen und variablen Punkteabständen erstellt. Der Punkteabstand wurde zwischen 0,00005\,\si{\m} und 0,005\,\si{\m} variiert. Bis zu einem Punkteabstand von 0,0025\,\si{\m} blieb die Genauigkeit des IEFD-Verfahrens sehr hoch und lieferte sowohl für die Kantenerkennung als auch für die Kantensegmentierung gute Ergebnisse. Bei einem Punkteabstand von 0,005m fiel die Genauigkeit des Verfahrens deutlich ab. Nur bei der höchsten Punktdichte wurden die Innen- und Außenkante der Testdatei nicht erkannt. Beim dritten Test wurde die Robustheit des Verfahrens überprüft. Hierbei wurden zwei Untersuchungen durchgeführt. Bei der ersten Untersuchung wurde eine zufälliges Rauschfaktor zur Verzerrung des Punktmusters verwendet. Damit wurde eine Störung des regelmäßigen Punktemusters erzielt. Das Rauschfaktor wurde zwischen 0,1 und 1,5 variiert. Bis zu einem Rauschfaktor von 0,8 wurde keine Beeinträchtigung der Leistung des Verfahrens beobachtet. Es wurden perfekte Ergebnisse für die Genauigkeit des Verfahrens erzielt. Auch bis zu einer Rauschfaktor von 1,0 wurde für die Kantenerkennung sehr gute Ergebnisse beobachtet. Im Gegensatz dazu sind die Ergebnisse der Kantensegmentierung relativ schlechter gewesen. Bei der höheren Rauschfaktoren wurden auch teilweise die falschen Kanten zwischen einzelner Iterationen nicht vollständig entfernt und haben die Kantensegmentierung gestört. Demzufolge sind die Ergebnisse der Kantensegmentierung bei einer Erhöhung des Rauschfaktors schlechter geworden. Dieser Trend wurde bis zu einer Rauschfaktor von 1,3 beobachtet, bis beide Metriken \textit{p\textsubscript{dct}} und \textit{p\textsubscript{mjt}} für die Kantensegmentierung zu einem Wert von 0,4 beziehungsweise 0,34 tendiert haben. Die Kantenerkennung lieferte im Gegensatz dazu deutlich bessere Ergebnisse. Es wurden alle Seitenränder sowie die Innen- und Außenkante richtig erkannt. Ab einem Rauschfaktor von 0,9 wurden die Spuren falscher Kanten zwischen Iterationen auch erkannt. Diese Anzahl stieg bis zu einem Rauschfaktor von 1,3 an, bevor sie wieder leicht abfiel. Ab einem Rauschfaktor von 1,3 konnten falsche Kanten weniger deutlich erkannt werden. Bei der zweiten Untersuchung des dritten Tests in Abschnitt~\ref{test_3} wurde die Genauigkeit des Verfahrens bei Anwendung auf vier Punktwolken reeller Bauteile überprüft. Es wurden hierfür Bauteile mit unterschiedlichen geometrischen Merkmalen wie Löcher, kreisförmige sowie rechteckige Aussparungen, Nuten und Innenkanten verwendet. Für alle vier Bauteile wurden gute bis sehr gute Ergebnisse für die Kantenerkennung sowie die Kantensegmentierung erzielt. Die Seitenränder, Innenkante und Aussparungen der Bauteile wurden immer richtig erkannt. Die Erkennung aller Kanten der Nuten sowie der Löcher erfolgte gegenteilig nicht immer akkurat. Die Kantensegmentierung der Seitenränder, Innenkanten und der Aussparungen erfolgte in den überwiegenden Fällen richtig. Manchmal wurden diese Kanten nicht vollständig segmentiert, sondern wurden zusätzliche Segmente erzeugt. Die Kanten der Nuten mit einer höheren Anzahl an Störpunkte konnten durch das Verfahren nicht vollständig segmentiert werden. Auch die kreisförmigen Löcher stellten eine Hürde für die Kantensegmentierung dar. 

Bei der Konzipierung des Verfahrens sowie bei der Auswertung der Testergebnisse sind viele Einzelheiten zur Erkenntnis gekommen. Bei diesen Erkenntnissen handelte es sich unter anderem um Anmerkungen zu der Leistungsfähigkeit des Verfahrens sowie mögliche Erklärungen der Ergebnisse

\section{Erkenntnisse aus der Methodik und Ergebnisse} \label{Erkenntnisse}

Die wichtigste Anmerkung zu der Leistung und Rechenzeit des Verfahrens erfolgte bei der Parallelisierung der \textit{\hyperref[alg:find_edge_points]{FindEdgePoints}}-Methode. Auf einem Ryzen 5 3600 Prozessor \autocite{noauthor_amd_2022} mit sechs Kernen und 12 Threads und einer Basistaktrate von 3,6 GHz wurde eine siebenfache Leistungsverbesserung beobachtet. Eine Punktwolke mit ca. 450.000 Punkte konnte vor der Parallelisierung innerhalb 162 Sekunden verarbeitet werden. Nach der Parallelisierung erfolgte die Kantenerkennung innerhalb 22,5 Sekunden. Es ließ sich postulieren, dass Kanten durch die Verwendung eines Prozessors mit mehr Kernen noch schneller erkannt werden könnten. Die Verwendung eines Grafikprozessors, die deutlich mehr Kernen besitzen, hätte die Leistung der Kantenerkennung für sehr großen Punktwolken enorm steigern können.

Die zweite Erkenntnis bei der Reproduktion des AGPN Verfahrens ist für die Implementierung auf einem Linux-basierten System relevant. Die Kantenerkennung erfolgte auf der neueren Version des Betriebssystems - Ubuntu Jammy Jellyfish (Version 22.04) - reibungslos und lieferte sehr gute Ergebnisse. Die Wiederholung des Programms auf eine ältere Generation des Betriebssystems - Ubuntu Focal Fossa (Version 20.04) - lieferte im Gegensatz schlechtere Ergebnisse. Ein Fehler seitens der Hardware wurde ausgeschlossen, indem der gleiche Rechner mit konstanten Spezifikationen für beide Betriebssysteme verwendet wurde. Auch der Einfluss fremder Software auf dem Programm wurde ausgeschlossen, indem das Programm an Betriebssysteme nur mit den notwendigen Softwareabhängigkeiten ausgeführt wurde. Eine genauere Untersuchung lieferte den Hinweis, dass die Standardversion der PCL-Bibliothek für beide Betriebssysteme unterschiedlich war. Die PCL-Bibliotheksversion 1.10 wurde Standardweise mit Ubuntu Focal Fossa geliefert, wobei die Version 1.12 Standardweise mit Ubuntu Jammy Jellyfish geliefert wurde. Das Downsampling-Verfahren aus der Bibliotheksversion 1.10 konnte sehr dichte Punktwolken nicht korrekt verarbeiten. Der Fehler wurde allerdings in der neueren Version der Bibliothek behoben. Aus diesem Grund lässt es sich empfehlen, entweder die Ubuntu Version 22.04 zu verwenden oder die Standardversion der PCL-Bibliothek zu entfernen und stattdessen die Version 1.12 zu installieren. Abbildung~\ref{fig: pcl_version_comparision} zeigt die Randpunke und im weiteren Sinne die Kanten, die nach dem fehlerhaften Downsampling erkannt wurden.


\begin{figure}[t]
	\centering
	\begin{subfigure}[h]{0.49\textwidth}
		\includegraphics[width=\textwidth]{Abbildungen/blech_edges.png}
		\centering
		\caption{Randpunkte mit PCL 1.12}
		\label{fig: blech_edges}
	\end{subfigure}
	\hfill
	\begin{subfigure}[h]{0.49\textwidth}
		\includegraphics[width=\textwidth]{Abbildungen/blech_bad_edges.png}
		\centering
		\caption{Randpunkte mit PCL 1.10}
		\label{fig: bad_edges}
	\end{subfigure}
	\caption[Einfluss der Softwareversion auf dem Verfahren]{Randpunkte, die durch beider Versionen von PCL erkannt werden}
	\label{fig: pcl_version_comparision}
\end{figure}

Während der Entwicklung der Methoden zur Entfernung falscher Kanten aus Abschnitt~\ref{false_edges} wurden Anmerkungen zu der Leistung und Genauigkeit der ersten Methode gemacht. Obwohl dieses Verfahren theoretisch funktioniert, lieferte es unzureichende Ergebnisse. Die Ungenauigkeit der \textit{Bounding-Box} wurde durch die sehr hohe Dichte der Punktwolke beziehungsweise den sehr kurzen Abstand zwischen Punkten verstärkt. Bei einem mittleren Punktabstand von weniger als 0,1 mm führte die inhärente Ungenauigkeit der \textit{Bounding-Box} dazu, dass übermäßig viele Randpunkte entfernt wurden. Darüber hinaus kosteten die Transformation der Punktwolke und weiteren Berechnungen zusätzliche Rechenleistung und eigneten sich für zeitintensive Operationen nicht, weil sie eine Zeitkomplexität von ungefähr $\mathcal{O}(n^2)$ aufwiesen. Dies lag daran, dass die \textit{n} Punkte der Punktwolke in einer Matrix geordnet und danach transponiert wurden. Deswegen wurde die zweite Methode zur Entfernung falscher Segmente bevorzugt, da sie eine niedrigere Zeitkomplexität aufwies. Bei der Konzipierung beider Methoden zur Entfernung falscher Kanten wurde nebenbei auch ein zusätzliches Konzept entworfen. Bei diesem Verfahren sollte die Position sowie das Koordinatensystem des Sensors während der Abtastung ausgenutzt werden. Es sollten ähnlich wie bei der ersten Methode zwei Regionen definiert werden, die alle falschen Kanten umfassen würden. Hierzu sollten die Positionen des Sensors am Anfang und am Ende jeder Iteration aufgespeichert werden, um die Positionen der falschen Randpunkte an den jeweiligen Seiten zu bestimmen. Das Koordinatensystem wird zum Setzen der Regionen verwendet werden. Die x-Achse würde als Stützvektor der Tiefe, die y-Achse als Stützvektor der Breite und die z-Achse als Stützvektor der Höhe dienen. Die y-Achse des Sensors entspricht seinem Richtungsvektor. Zur Dimensionierung der Regionen sollten die Sensorspezifikationen verwendet werden. Der Lasersensor aus Abschnitt~\ref{test_data} dieser Arbeit kann 290 mm in der x-Richtung und 460 mm in der z-Richtung scannen. Auf diesen Werten wird ein zusätzlicher Puffer addiert, sodass die Regionen möglichst alle falschen Randpunkte umfassen würden. Das Ausmaß für die Breite \textit{b} dieser Regionen ist durch den Benutzer angegeben werden. Während der Konzipierung dieses Verfahrens wurde jedoch gezeigt, dass die Sensorposition nicht immer Vertikal über das Bauteil lag, sondern meistens abgesetzt und in einer anderen Orientierung zu ihm lag. Als Lösungsansatz könnten die Randpunkte nach dem Koordinatensystem des Sensors transformiert werden, allerdings würde es eine Transponierung der Punkte benötigen, welche eine Zeitkomplexität von $\mathcal{O}(n^2)$ hat. Deswegen wurde diese Methode zur Entfernung falschen Kanten nicht vervollständigt und diese Zeit zur Entwicklung der zweiten Methode investiert. 

Das wichtigste Erkenntnis des ersten Tests ist die Bestätigung der ersten Hypothese. Das IEFD-Verfahren hat zu einer hohen Genauigkeit alle Kanten der Testdatei erkennt und segmentiert. Aufgrund der hohen Einheitlichkeit des Punkteabstandes, der gleichmäßigen Höhe aller Punkten einer Ebene sowie der klaren Trennung der Ebenen wurden alle Seitenränder und die Innen- sowie Außenkante vollständig erkannt und segmentiert. Allerdings ist das gleiche nicht für das AGPN-Verfahren geschehen. Trotz Verwendung der gleichen Testdatei hat das AGPN-Verfahren die Faltungen des Bauteils überhaupt nicht erkannt. Da alle Parameter beider Verfahren den gleichen Wert hatten und konstant gehalten wurden, lässt sich überlegen, ob die Anzahl der verarbeiteten Punkte einen Unterschied machen könnte. Während die Testdatei durch das IEFD-Verfahren zerlegt und stückweise verarbeitet wurde, wurde durch das AGPN-Verfahren die gesamte Testdatei in einem Zug verarbeitet. Die Anzahl der Punkte, die durch das IEFD-Verfahren in einem Zug verarbeitet wurden, ist eine Teilmenge der gesamten Punktezahl gewesen, die durch das AGPN-Verfahren verarbeitet wurden. Somit ist das Verhältnis zwischen \textit{K\textsubscript{1}} und der Anzahl der zu verarbeitenden Punkte für beide Verfahren unterschiedlich groß gewesen.

\begin{displaymath}
	\eta_{agpn} = \frac{K_1}{n}, \text{n = Anzahl der gesamten Punkte.}
\end{displaymath}
\begin{displaymath}
	\eta_{iefd} = \frac{K_1}{n_i}, n_i \subset n
\end{displaymath}
\begin{displaymath}
	\eta_{iefd} > \eta_{agpn}
\end{displaymath}

Die Ergebnisse des AGPN-Verfahrens könnten durch die Wahl eines höheren Wertes für \textit{K\textsubscript{1}} verbessert werden.

Die Ergebnisse des zweiten Tests haben die zweite Hypothese nicht bestätigt. Die Genauigkeit hat sich nicht proportional zu der Punktedichte verhalten, sondern konnte kein Trend eindeutig erkannt werden. Bei einer geringeren Anzahl an gesamten Punkten die Bestimmung der Richtungsvektoren schwieriger wird, was in einer schlechteren Genauigkeit der Kantensegmentierung resultiert. Bei einer sehr hohen Gesamtzahl an Punkte¸ werden wiederum unzureichende Punkte zur Erstellung der Ebene \textit{E\textsubscript{N\textsubscript{o}}} beim \textit{\hyperref[alg:find_edge_points]{FindEdgePoints}} verwendet. Diese ungenügende Anzahl an Punkte in einer Nachbarschaft \textit{N\textsubscript{o}} könnten möglicherweise dazu führen, dass sie zur eindeutigen Abbildung zweier Ebenen an der Schnittlinie einer Innen- oder Außenkante nicht ausreichen. Der Verlauf der Genauigkeit wird einfach logarithmisch in Abbildung~\ref{fig: point_density_trend} dargestellt und hebt die Abwesenheit eines erkennbaren Trends hervor. Je mehr der Punkteabstand erhöht wurde, desto wenige Punkte wurden in der Testdatei generiert. Die Ursache dieses Verhaltens sind die konstanten Dimensionen der Testdatei gewesen. Wie es auch in Abbildung~\ref{fig: testdata_0,005m} zu sehen ist, ist die Erkennung geometrischer Merkmale der Testdatei schwerer geworden. Es lässt sich überlegen, ob die Genauigkeit des Verfahrens mit der Anzahl der Punkte statt der Punktedichte korreliert. Das obige Postulat aus dem ersten Test - das Verhältnis zwischen der Anzahl der zu verarbeitenden Punkte und \textit{K\textsubscript{1}} - würde die niedrigere Genauigkeit der Kantenerkennung bei sehr kurzen Punkteabständen von 0,00005\,\si{\m} auch erklären. Bei diesem Punkteabstand wurden 48.000.000 Punkte in der Testdatei generiert sowie circa 1.200.000 Punkte in jeder Iteration des IEFD-Verfahrens verarbeitet. Zum Vergleich wurden bei einem Punkteabstand von 0,00025\,\si{\m} circa 240.000 Punkte in jeder Iteration verarbeitet. Dies führte möglicherweise zu einem unzureichenden Wert von $\eta_{iefd}$ von circa 0,00017. Auch die Kantensegmentierung scheint von der Anzahl an Punkten abhängig zu sein. Aufgrund der wenigen Punktezahl in jeder Iteration  wurde die genaue Bestimmung der Richtungsvektoren erschwerte. Auch die Anzahl der Punkte in den wiederholten Scan-Linien wurden weniger. Diese Folgen der höheren Punkteabstände hatten möglicherweise den Effekt, dass die Richtungsvektoren neuer Punkte zu sehr von den Richtungsvektoren der vorhanden Segmente abgewichen haben, um diese zu erweitern. 

\begin{figure}[t]
	\includegraphics[width=0.85\textwidth]{Abbildungen/point_density_log_scale.png}
	\centering
	\caption[Verhältnis zwischen Genauigkeit und Punkteabstand]{Der Verlauf der vier Metriken bei einem steigenden Punkteabstand}
	\label{fig: point_density_trend}
\end{figure}

Für den dritten Test lässt sich die allgemeine Aussage treffen, dass die dritte Hypothese bestätigt wurde. In beiden teilen der dritten Untersuchung konnte das IEFD-Verfahren zuverlässige und gute Ergebnisse liefern. Bis zu einer Rauschfaktor von 1,0 der wurden sehr gute Ergebnisse für die Kantensegmentierung beobachtet. Die Erzielung einer perfekten Bewertung wurde dadurch verhindert, dass die falschen Kanten zwischen Iterationen nicht deutlich und lückenlos erkannt wurden. Dies führte dazu, dass die Segmentierung dieser falschen Kanten unvollständig erfolgte. Auch die Anzahl der Störpunkte ist mit dem Rauschfaktor gestiegen, infolgedessen die Erweiterung vorhandener Segmente beeinträchtigt wurde. Die Werte für die Metriken \textit{p\textsubscript{dct}} und \textit{p\textsubscript{mjt}} scheinen bei den höheren Rauschfaktoren gegen einem Wert zwischen 0,34 und 0,40 zu tendieren. Dies könnte daran liegen, dass die falschen Kanten zwischen Iterationen ab einer Amplitude von 1,4 weniger deutlich zu erkennen waren. Gleichzeitig sind die Anzahl der Störpunkte auch gestiegen. Aufgrund des großen Rauschfaktors haben die lokale Punktedichten der Nachbarschaften \textit{N\textsubscript{o}} und \textit{N\textsubscript{p}} zu sehr variiert, wodurch kleine Lücken entstanden entstanden sind. Die angrenzenden Punkte dieser kleinen Lücken wurden folglich als Randpunkte markiert. Diese Punkte haben für die Kantensegmentierung allerdings eher als Störpunkte gewirkt. Eine Anpassung von \distthresha und \distthreshb als Gegenwirkung gegen der kleinen lokalen Löcher hätte zu besseren Ergebnissen führen können. 

Die zweite Teiluntersuchung des dritten Tests in Abschnitt~\ref{test_3_part_2} hat gezeigt, dass das IEFD-Verfahren gute Ergebnisse bei der Verarbeitung von Punktewolken reeller Bauteile liefert. Der Wert für \distthresha wurde immer so gewählt, dass es dem durchschnittlichen Abstand der Punkte gleich war. Der Wert für \distthreshb wurde auf Basis der Objektgeometrien gewählt. Für sehr feine Geometrien wurde der Wert für \distthreshb dem Wert von \distthresha gleichgesetzt. Bei gröberen Geometrien wurde der Wert um ein größeres Wert gewählt, um die Kriterien zur Erweiterung bestehender Segmente aufzulockern. Infolgedessen konnten auch Kanten, die sehr nah beieinander lagen. Das Verfahren hatte  Schwierigkeiten bei der Erkennung und Segmentierung von kreisförmigen Löchern des Schweißtisches. Der Grund hierfür lag daran, dass die Kanten der Kreise von einem Rand auf eine Außenkante übergingen. Dieser Übergang ist in Abbildung~\ref{fig: Loch} abgebildet. Es lässt sich behaupten, dass die Kantenerkennung bei allen ähnlichen Übergängen von Ränder auf Außen- oder Innenkanten fehlschlagen würde. Spiegelbildlich lässt sich auch behaupten, dass die Kantenerkennung für solche Bereiche durch die Anpassung der Prozessparameter verbessert werden könnte. Es wurde auch die Erkenntnis gewonnen, dass die Anzahl der wiederholten Scan-Linien \textit{k} auch einen Einfluss auf die Genauigkeit der Kantensegmentierung hat. Bei einem unzureichenden Wert für \textit{k} wurden immer neue Segmente in neuen Iterationen erzeugt, obwohl vorhandene Kanten erweitert werden konnten. Eine höhere Anzahl von Scan-Linien würden die Wahrscheinlichkeit erhöhen, dass Punkte mit dem gleichen Richtungsvektor als vorhandenen Segmente gefunden werden, allerdings würde widersetzlich auch der Rechenaufwand für die Kantensegmentierung sich erhöhen. Die Bestimmung des Verhältnis der Genauigkeit zu der Anzahl der wiederholten Scan-Linien wurde allerdings im Umfang dieser Arbeit nicht bestimmt. Es lässt sich allerdings behaupten, dass die Erhöhung von \textit{k} über einem bestimmten Wert auch die Genauigkeit nicht erhöhen würde, nur den Rechenaufwand. Über den Umfang der dritten Untersuchung hinaus wurden die gleichen vier Bauteile auch mit dem AGPN-Verfahren prozessiert. Ähnlich zu dem ersten Test aus Abschnitt~\ref{test_1} wurde die Innenkante der Bauteile nicht durch das Verfahren erkannt. Die Kantensegmentierung erfolgte allerdings mit ähnlich guten oder leicht besseren Ergebnissen. 

\begin{figure}[t]
	\includegraphics[scale=0.62]{Abbildungen/Loch.png}
	\centering
	\caption[Übergangsregion zweier Kanten]{Der Übergang von einem Rand auf eine Faltung des kreisförmigen Loches}
	\label{fig: Loch}
\end{figure}

Einen Vergleich der Genauigkeit des IEFD-Verfahrens mit anderen Verfahren aus~\ref{Stand_der_technik} liefert die folgenden Erkenntnisse. Die Implementierung dieser Verfahren sowie das Austesten dieser Verfahren mit den Punktwolken dieser Arbeit ragt über dem Umfang dieser Arbeit heraus. Stattdessen wurden die Ergebnisse der jeweiligen Beiträge aus der Literatur mit den Ergebnissen der reellen Bauteile dieser Arbeit verglichen. Das Verfahren nach \textcite[7353]{ahmed_edge_2018} kann zu einer niedrigeren Genauigkeit wie das IEFD-Verfahren Kanten erkennen. Hierfür wird der Wert für \textit{Recall} verwendet, da es dem Metrik \textit{p\textsubscript{dc}} entspricht. Bei einem \textit{Recall}-Wert von ca. 80\% wird auch eine hohe Genauigkeit (\textit{Precision}) von circa 85\% erzielt. \textcite[88]{mineo_novel_2019} und \textcite{choi_rgb-d_2013} haben die Genauigkeit ihres Verfahrens nicht empirisch bestimmt. Minieo, Pierce et al. bewerten ihr Verfahren auf die Robustheit gegen Rauschen und stellen fest, dass mit einem Rauschen von 25\% der Gesamtzahl an Punkten wird mindestens ein Randpunkt nicht korrekt erkannt. In der Arbeit von Choi, Trevor et al. wird die Genauigkeit des Verfahrens nur qualitativ bewertet. Das Verfahren nach \textcite[11]{bazazian_edc-net_2021} hat auch einen durchschnittlichen \textit{recall} Wert von 0,84 beziehungsweise 84\%. Auch das Verfahren nach \textcite[9]{himeur_pcednet_2021} hat eine ähnliche Genauigkeit für die Kantenerkennung aufweisen können. Das Verfahren nach \textcite{lu_fast_2019} kann strukturelle Kanten deutlich schneller als alle anderen Verfahren aus Abschnitt~\ref{Stand_der_Technik} erkennen, allerdings ist die Erkennung von Kurven eine Schwachstelle. Das AGPN-Verfahren kann laut \textcite{ni_edge_2016} zu einer ähnlichen Genauigkeit wie das IEFD-Verfahren Kanten erkennen. Die Implementierung des AGPN-Verfahrens in dieser Arbeit weist abweichende Ergebnisse auf. Wie bereits in Abschnitt~\ref{test_1} erwähnt, hat das Verfahren die Innen- und Außenkante der Testdatei nicht erkannt. Auch die Innenkanten der reellen Bauteile wurden sehr dürftig oder überhaupt nicht erkannt. Die Kantensegmentierung nach \textcite[234]{hu_jsenet_2020} erzielt eine Genauigkeit von fast 70\% und schneidet somit deutlich unter dem IEFD-Verfahren ab. Das AGPN-Verfahren weist im Gegensatz dazu eine vergleichbare hohe Genauigkeit bei der Kantensegmentierung wie das IEFD-Verfahren. Im Allgemeinen lässt sich die Aussage treffen, dass die Kantenerkennung und Kantensegmentierung des IEFD-Verfahrens überdurchschnittlich im Vergleich zu anderen Verfahren der Literatur abschneidet. Das Verfahren zeigt auch bessere Ergebnisse als das AGPN-Verfahren vor, worauf es basiert. Allerdings ist das Verfahren nicht ohne seine Schwachstellen. Die Verarbeitung von dürftigen Punktwolken mit wenig Punkten stellt eine Hindernis für das Verfahren dar. Dieses soll allerdings den Einsatz des Verfahrens unter reellen Bedingungen nicht verhindern, da die Aufnahme eines Objektes selten in solchen dürftigen Punktwolken resultiert. Auch eine sehr hohes Rauschen in der Punktwolke führt zu schlechteren Ergebnissen des IEFD-Verfahrens, welche durch eine Anpassung der Prozessparameter kompensiert werden könnten. Das wichtigste Erkenntnis aus dieser Arbeit liegt an der Tatsache, dass der Umfang dieser Arbeit nicht ausreichend war, das IEFD-Verfahren vernünftig und gründlich zu überprüfen.

\section{Limitationen dieser Arbeit}
Im Umfang dieser Arbeit wurden die Angaben aus dem Referenzwerk nach \textcite{ni_edge_2016} verwendet, um das AGPN-Verfahren zu reproduzieren sowie die drei Tests zur Überprüfung der Genauigkeit zu gestalten. Da die Implementierung des Verfahrens durch den Autoren der Referenzwerk nicht öffentlich zugängig gemacht wurde, musste die Methodik durch den Verfasser dieser Arbeit interpretiert werden. Deswegen kann es nicht gewährleistet werden, dass diese Implementierung des AGPN-Verfahrens identisch zu der des Referenzwerks funktioniert. Dies hätte beispielsweise dazu führen können, dass die Kantenerkennung des AGPN-Verfahrens in dieser Arbeit und in dem Referenzwerk abweichende Ergebnisse geliefert haben. Wie bereits erwähnt, konnte das AGPN-Verfahren die Innen- und Außenkante der Testdatei nicht erkennen, obwohl es laut dem Referenzwerk zu erwarten wäre. Die synthetische Testdatei setzt sich aus simplen Geometrien zusammen und weist keine komplexen Merkmale auf. Dank der niedrigen Komplexität ist es einfach gewesen, die Anzahl der Kanten sowie der Randpunkte visuell zu bestimmen. Die Abwesenheit von komplexen Geometrien hat allerdings dazu geführt, dass die Grenzen des IEFD-Verfahrens in den drei Untersuchungen nicht gründlich ausgetestet werden konnten. Die Auswahl eines breiteren oder umfangreicheres Spektrum an Punktwolken reeller Bauteile und Objekte hätten auch die Plausibilität des dritten Tests verbessern können und mehr Ergebnisse für den Vergleich mit der Literatur bereitstellen können. Die Untersuchung der Einflüsse der sechs Prozessparameter des IEFD-Verfahrens sowie der drei Parameter der Testumgebung auf die Genauigkeit konnte im Rahmen dieser Arbeit nicht behandelt werden. Eine solche Untersuchung könnte wichtige Erkenntnisse liefern. Diese Arbeit konzentriert sich auf die Überprüfung der Eignung des IEFD-Verfahrens für eine industrielle Anwendung hinsichtlich der Genauigkeit. Eine Überprüfung und einen Vergleich der Performanz des Verfahrens könnte allerdings auch wertvolle Erkenntnisse liefern. Die Evaluierungsmetriken sind für den Zweck dieser Arbeit sinnvoll gewählt worden. Für die angezielten Anwendungsgebiete ist die richtige Erkennung und Segmentierung der geometrischen Merkmale von Wert. Andere Evaluierungsmetriken wie die \textit{Precision}, \textit{Recall} und der F-Maß  Metriken, die in den Beiträgen von \textcite{bazazian_edc-net_2021}, \textcite{ahmed_edge_2018}, \textcite{himeur_pcednet_2021} und \textcite{hu_jsenet_2020} verwendet wurden, könnten weitere Einblicke in dem IEFD-Verfahren erzeugt. Trotz der Limitationen sind die Erkenntnisse dieser Arbeit nicht zu vernachlässigen, sondern liefern wichtige Hinweise über die Einsatzfähigkeit und Genauigkeit des IEFD-Verfahrens.


%behaupten, dass die Anzahl der Nachbarpunkte \textit{K\textsubscript{1}} und \textit{K\textsubscript{2}} einen vernachlässigbaren Einfluss auf die Genauigkeit des Verfahrens haben.