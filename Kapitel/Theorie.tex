%Datenstrukturen und Algorithmen
%	Was sind Algorithmen und Datenstrukturen
% 	Arten von Basis Datenstrukturen
%		Vector/Liste
%		Queue(Warteschlange)
%		Stack??
%		map und hash tabellen
%	besondere Datenstruktur - PCL Punktwolke
%	
%	Komplexität und Notation von Algorithmen
%	Arten von Basis Algorithmen
%		
% 		
%	besondere Algorithmen:
%		kd-tree
%		octree(vielleicht)
%		RANSAC
%		Segmentierung

\chapter{Theorie}
Im Kern dieser Arbeit steht eine Rechenaufgabe vor. Die positionellen Informationen über Objekte und Bauteile müssen sinnvoll verarbeitet werden, um die Lage und Form der geometrischen Merkmale des Objektes zu bestimmen. Bei der Entwicklung eines allgemeinen Verfahrens zur Erkennung der geometrischen Merkmale in Abschnitt~\ref{Methodik} werden Algorithmen und Datenstrukturen verwendet. 

\section{Datenstrukturen}

Datenstrukturen dienen der Organisation und Speicherung von Daten so, dass die Beziehung zwischen einzelnen Elemente auch aufbewahren wird. In einer Datenstruktur werden darüber hinaus auch Zugriffsmethoden für den Zugriff auf die gespeicherten Daten definiert sowie Angaben über Möglichkeiten zur Verarbeitung der Daten gemacht. Eine gute Datenstruktur setzt voraus, dass die Beziehung zwischen der Daten aufbewahren und gut definiert wird sowie die Verarbeitung der Daten leicht gemacht wird. Eine Datenstruktur soll auch bestimmte Operationen auf die Daten ermögliche, beispielsweise die Hinzufügung oder Entfernung von Datenpunkte, die Zusammenführung oder Sortierung der Daten sowie das Durchqueren der Datenstruktur und die Suche nach bestimmten Daten. In der Informatik gibt es bereits etablierte Datenstrukturen, die sich nach unterschiedlichen Einsatzzwecken richten und eine sehr breite Anwendung finden. Diese lassen sich nach Abbildung \ref{fig: datastructures} nach lineare und nichtlineare Datenstrukturen unterteilen. \autocite[1-2]{mohanty_data_2021}

\begin{figure}[h]
	\includegraphics[width=\textwidth]{Abbildungen/Datenstruktur_arten.png}
	\centering
	\caption{Die unterschiedlichen Arten von linearen und nichtlinearen Datenstrukturen nach \textcite[2]{mohanty_data_2021}}
	\label{fig: datastructures}
\end{figure}

\subsection{Lineare Datenstrukturen}
Eine lineare Datenstruktur ist eine Datenstruktur, bei der die Elemente in einer sequentiellen Reihenfolge angeordnet sind. Dies bedeutet, dass jedes Element genau einen Vorgänger und einen Nachfolger hat, außer dem ersten und letzten Element. Lineare Datenstrukturen können als tabellarische Liste oder als verkettete Liste implementiert werden. \autocite[314-315]{hoffmann_einfuhrung_2011}

Die Operationen, die auf einer linearen Datenstruktur ausgeführt werden können, sind in der Regel das Initialisieren der Datenstruktur als leere Menge, das Einfügen eines Elements in die Datenstruktur und das Entfernen eines Elements aus der Datenstruktur. Es ist auch möglich, andere Operationen auszuführen, die nicht unbedingt auf der Ordnungsbeziehung zwischen den Elementen basieren. Unter diesen Operationen zählen beispielsweise das Suchen nach einem Element oder das Ersetzen eines Elements in der Datenstruktur. \autocite[314-315]{hoffmann_einfuhrung_2011}

Die Implementierung einer linearen Datenstruktur kann je nach Anforderungen und verfügbaren Ressourcen variieren. Es ist jedoch wichtig sicherzustellen, dass die Datenstruktur korrekt implementiert ist und dass alle Operationen den Zustand der Datenstruktur ordnungsgemäß ändern. \autocite[314-315]{hoffmann_einfuhrung_2011}

Unter der linearen Datenstrukturen finden hauptsächlich drei Datenstrukturen eine breite Anwendung, nämlich Felder (Arrays), Schlangen (Queues) und Stapel (Stacks).

\subsubsection{Felder}

Das Feld ist einer der einfachsten linearen Datenstrukturen. Ein Feld besteht aus mehreren Daten des gleichen Formats oder Datentyps, die je nach Implementierung in aufeinanderfolgenden Speicherorten gespeichert werden. Diese werden sequenziell hintereinander angeordnet und zusammen gespeichert. Elemente eines Feldes dürfen eindimensional oder auch mehrdimensional gespeichert werden, wodurch diese Datenstruktur mit Matrizen oder Vektoren aus der Mathematik verglichen werden kann. Die Größe oder Dimension des Feldes wird immer vorgegeben und bleibt in der Regle statisch. Jedes Element eines Feldes besitzt einen sogenannten Index, welcher auf die Position des Elements in dem Feld deutet. Im Falle eines zwei Dimensionalen Feldes besitzt jedes Element der Datenstruktur zwei Indizes. In der regel deutet das erste Index auf die Zeile und das zweite Index auf die Spalte des Datenfeldes hin, allerdings kann dieser Regel von Implementierung zu Implementierung variieren. Felder dürfen eine beliebig Anzahl \textit{n} Dimensionen besitzen, allerdings steigt somit auch die Anzahl der Indizes aller Elemente. Datenfelder über vier Dimensionen können sogar räumlich nicht vorgestellt werden, jedoch macht es für einen Rechner kein Problem. Zugriffsoperationen auf Elemente sowie Operationen zur Einfügung und Entfernung dieser Elemente verwenden ihre Indizes, um den Eintrag an einer bestimmten Position des Feldes aufzurufen oder zu manipulieren. \autocite[35-36]{ollmert_datenstrukturen_2020}

Eine andere Variante der Felder ist die sogenannte lineare Liste. Diese Liste unterscheidet sich von Felder, indem sie dynamisch initialisiert werden darf. Im Gegensatz zu der statischen Größe oder Dimension eines Feldes, darf die Größe einer linearen Liste beliebig geändert werden. Während ein Feld mit maximale Größe \textit{n} und \textit{n} Elemente nicht um ein weiteres Element \textit{k} erweitert werden darf, kann eine lineare Liste der gleichen Größe mit den gleichen Anzahl an Elementen um das \textit{k-te} Element erweitert werden. Das Element darf auch an einer beliebigen Stelle der Liste eingefügt werden. Die Reihenfolge beziehungsweise die Positionen der anderen Elemente werden automatisch angepasst. Dies könnte auch dazu führen, dass ein Element Z, welches zum Zeitpunkt T1 vor der Einfügung eines neuen Elements einen bestimmten Index \textit{i} besaß, zu einem Zeitpunkt T2 nach der Einfügung nicht mehr an der gleichen Position zu finden ist. Das gleiche kann auch durch die Entfernung von Elementen an beliebigen Positionen geschehen. Die Positionen und somit die Indizes alle Elemente dürfen auch geändert werden, indem sie Beispielsweise nach einem Kriterium sortiert wurden. \autocite[40-42]{ollmert_datenstrukturen_2020}

Lineare Listen bieten viele ähnlichen Operationen wie die von Feldern an, um mit den eingespeicherten Elementen zu interagieren. Dazu gehört das Abrufen eines bestimmten Elements, das Einfügen eines neuen Elements zwischen zwei benachbarten Element (sowie Spezialfälle für das Hinzufügen eines neuen ersten oder letzten Elements), das Entfernen eines bestimmten Elements, das Bestimmen der aktuellen Länge der Liste anhand der Elementanzahl, die Suche nach einem Element mit einem bestimmten Wert, das Zusammenführen von zwei linearen Listen und das Aufteilen einer Liste in zwei Teillisten.\autocite[42-43]{ollmert_datenstrukturen_2020}


Verketteten linearen Listen sind eine bestimmte Art der Implementierung von linearen Listen. Eine solche Kette unterscheidet sich grundsätzlich nach ihrem Aufbau und Speicherverfahren von gewöhnlichen Listen und Feldern. Die Elemente einer verketteten linearen Liste werden nicht aufeinanderfolgend gespeichert. Stattdessen wird mit jedem Element dieser Liste auch ein Zeiger beigegeben, der entweder die Speicheradresse des nächsten Elements angibt oder auf das Ende der Liste hinweist. Der Anker ist ein besonderer Zeiger, der auf den Anfang der Liste deutet. Die Struktur und Operationen einer linearen Liste ist in Abbildung \ref{label} abgebildet. Bei der doppel-verketteten linearen Listen werden mit jedem Element nicht nur einen Zeiger zu dem nächsten Element beigegeben, sondern auch einen Zeiger zu dem vorigen Element. Bei dieser Art der verketteten Liste werden zwei Anker geliefert - der Vorwärtsanker für den Anfang und der Rückwärtsanker für das Ende der Liste. Die Verarbeitung mancher linearen Listen stellt eine Herausforderung dar, insbesondere wenn sie gleichzeitig durch mehrere Programme verarbeitet werden. In solchen Fällen könnte es beispielsweise dazu führen, dass ein Programm auf ein bestimmtes Element mittels seines Index zugreift, während ein anderes Programm ein Element davor hinzufügt oder entfernt. \autocite[43-44]{ollmert_datenstrukturen_2020}

\begin{figure}[t]
	\includegraphics[width=\textwidth]{Abbildungen/Verkettete_lineare_liste.png}
	\centering
	\caption{Die Struktur und Operationen einer linearen Liste. Die Großbuchstaben deuten auf die Elemente der Liste während die \textit{z}-Buchstaben die Zeiger repräsentieren. Die Kopfzelle steht in dieser Abbildung für den Anker.\autocite[611]{ernst_grundkurs_2020}}
\end{figure}

Für alle gängigen Implementierungen von linearen Listen ist die Implementierung einer sequentiellen Zugriffsfunktion, die das nächste Element in der Liste ausgehend von einem bestimmten Element bereitstellt, einfach. Die Implementierung einer direkten Zugriffsfunktion, die das \textit{i}-te Element in der Liste bereitstellt, ist zwar ebenfalls einfach, aber die benötigte Zeit hängt von der Position des Elements in der Liste ab und nimmt mit zunehmender Länge der Liste zu.\autocite[45]{ollmert_datenstrukturen_2020}

\subsubsection{Schlangen}
Schlangen sind besondere sequentielle Datenstrukturen, die Daten nur in einer bestimmten Reihenfolge speichern. Dadurch wird auch die Entnahme und Einfügung der Daten geregelt. Schlangen folgen das Prinzip nach \textit{First-In-First-Out} (FIFO), also werden die Elemente zur Verfügung gestellt, die zuerst zu der Datenstruktur hinzugefügt wurden. Elemente dürfen in der Regel nur am Ende der Schlange eingefügt und vom Anfang der Schlange entnommen werden. \autocite[371]{gumm_band_2016}

Das Prinzip nach \textit{FIFO} wird üblicherweise mittels verketteten linearen Listen ermöglicht. Der Anfang sowie das Ende der Schlange werden mittels Zeiger gekennzeichnet. Jedes Element, welches zu der Schlange hinzugefügt wird, erhält je nach Art der verketteten Liste einen Zeiger zu dem Element davor oder danach. Im Falle des ersten oder letzten Elements wird ihm ein besonderer Zeiger - der Nullzeiger - zugewiesen. Dieses deutet darauf hin, dass es keine weiteren Elemente zu finden sind. Der Zeiger \textit{anfang} deutet somit auf das vorderste und älteste Element der Schlange während der Zeiger \textit{ende} auf das hinterste und neuste Element deutet. Sobald der erste Eintrag der Schlange gelesen oder entnommen wird, wird der Zeiger \textit{anfang} inkrementiert, sodass es auf das nächste Element zeigt. Wenn ein neues Element zu der Schlange hinzugefügt wird, wird der Zeiger \textit{ende} inkrementiert, sodass es auf den letzten Eintrag der Schlange deutet. \autocite[48-49]{ollmert_datenstrukturen_2020} \autocite[371]{gumm_band_2016}

Schlangen bieten ähnliche Operationen wie Felder und Listen an. Im Gegensatz zu Listen oder Felder, wo Elemente mittels einem bestimmten Funktionsaufruf an beliebigen Positionen innerhalb der Datenstruktur platziert werden dürfen, dürfen Elemente aus einer Schlange nur am Ende eingefügt werden. Abhängig von der Implementierung wird eine Methode bereitgestellt, die das Einfügen eines Elements ermöglicht. Allgemein wird das Einfügen einer Datei in einer Schlange als \textit{enqueue} benannt.Felder und Liste ermöglichen mittels bestimmter Funktionen einen Zugriff auf beliebige Elemente innerhalb der Datenstruktur in einer beliebigen Reihenfolge. Bei Schlangen darf nur das erste Element aus der Datenstruktur entnommen werden, welches am längsten in der Datenstruktur enthalten wurde. Auch wird der Zugriff auf dieses Element abhängig von der Implementierung durch eine bestimmte Methode ermöglicht. Allgemein wird das entfernen oder auslesen eines Elements einer Schlange als \textit{dequeue} bezeichnet. Die Anzahl der Elemente \textit{count} in einer Schlange lässt sich bestimmen, indem die Differenz zwischen den Zeigern \textit{anfang} und \textit{ende} berechnet wird. In den meisten Implementierungen werden diese Schritte innerhalb einer Methode zur Bestimmung der Länge eingekapselt. Diese Operationen zusammen mit den zur Erstellung und Vernichtung von Schlangen sind die Einzigen Methoden, die für diese Datenstruktur in der Regel bereitgestellt werden. \autocite[71-72]{hubwieser_fundamente_2015} \autocite[371]{gumm_band_2016}

Die Ausführung der Prozeduren enqueue und dequeue erfordert bei einer Schlange einen konstanten Zeitaufwand, der unabhängig von der Anzahl der Elemente in der Datenstruktur ist. Die Suche nach einem Bestimmten Element in einer Schlange erfordert jedoch einen Zeitaufwand, der linear von der Anzahl der aktuellen Elemente in der Datenstruktur abhängt. Zur Überprüfung, ob ein bestimmtes Element in einer Schlange vorhanden ist, muss im Durchschnitt die Hälfte der Schlange durchsucht werden. \autocite[318]{hoffmann_einfuhrung_2011}

\begin{figure}[t]
	\includegraphics[width=\linewidth]{Abbildungen/Queue.png}
	\centering
	\caption{Eine Schlange mit den Operationen zur Einfügung und Entfernung von Elementen dargestellt \autocite[371]{gumm_band_2016}}
	\label{fig: queue}
\end{figure}

\subsubsection{Stapel}
Die Datenstruktur des Stapels, auch bekannt als Keller oder Stack, ist eine homogene, sequentielle Struktur, die nur das Einfügen und Lesen von Elementen am Anfang der Struktur erlaubt. Beim Lesen eines Elements wird dieses gleichzeitig entfernt, so dass das folgende Element an den Anfang rückt. Stapeln folgen das Prinzip nach \textit{First-In-Last-Out (FILO)} oder \textit{zuerst-rein-zuletzt-raus}. Die Anzahl der Speicherplätze des Stacks ist einseitig potenziell unbegrenzt, so dass der Stack dynamisch wachsen und schrumpfen kann. \autocite[614]{ernst_grundkurs_2020}

Stapel werden üblicherweise als verketteten linearen Listen implementiert, die nur in eine Richtung expandieren oder reduzieren dürfen. Somit erfolgt die Einfügung sowie die Entnahme von Elementen im Gegensatz zu Schlangen nur am einen Ende des Stapels. Bei der Einfügung jedes neuen Elements werden die Vorhandenen Elemente des Stapels zurückgeschoben und dem neuen Element wird einen Zeiger zum vorigen Element beigegeben. Im Falle des ersten Elements wird ihm ähnlich wie zuvor einen Nullzeiger zugewiesen, der auf dem Ende des Stapels hinweist. Elemente des Stapels dürfen nur in der umgekehrten Reihenfolge ausgelesen werden, in der Sie eingefügt wurden. Somit dürfte das allererste Element nur als allerletztes Element ausgelesen werden. \autocite[363]{gumm_band_2016}

Ähnlich wie Schlangen bieten Stapeln im Vergleich zu Felder und Listen nur begrenzte Funktionalitäten an. Elemente eines Stapels dürfen nicht an beliebigen Stellen zwischen vorhandenen Elementen des Stapels platziert werden, sondern nur am \textit{Kopf} des Stapels. Dieses wird durch die Operation \textit{push} ermöglicht, welches ein neues Element an der obersten Ebene platziert und den Zeiger für den Kopf nach oben nachrückt. Genau wie das Einspeichern darf das Auslesen eines Elementes nicht an einer beliebigen Stelle des Stapels erfolgen, sondern nur am Kopf des Stapels geschehen. Die Operation \textit{pop} ist dafür zuständig, das erste oder oberste Element des Stapels zu entfernen und für das Auslesen bereitzustellen. Gleichzeitig wird der Zeiger für den Kopf nach hinter gerückt, sodass es zu dem vorigen Element zeigt. Neben dieser Operationen werden auch für Stapeln zusätzliche Operationen bereitgestellt, die Stapeln erzeugen, vernichten oder seine Größe bestimmen. Wie diese Operationen definiert werden, hängt allerdings von der Implementierung ab. \autocite[614]{ernst_grundkurs_2020} \autocite[45-46]{ollmert_datenstrukturen_2020}

Im Prinzip funktioniert ein Stapel ähnlich zu einer Schlange, indem er das Auslesen oder Einfügen von Elementen nur an bestimmten Stellen erlaubt. \textit{Push} und \textit{pop} sind beide Operationen, die ähnlich wie \textit{enqueue} und \textit{dequeue} funktionieren und unabhängig von der Größe der Datenstruktur sind. Somit sollte der Zeitaufwand dieser Operationen auch konstant bleiben. Die Suche nach einem bestimmten Element in einem Stapel sollte ähnlich wie bei Schlangen direkt von der Anzahl der Elemente abhängen.

\begin{figure}[t]
	\includegraphics[width=\textwidth]{Abbildungen/Stack.png}
	\centering
	\caption{Ein Stapel mit den Operationen zur Einfügung und Entfernung von Elementen dargestellt \autocite[371]{gumm_band_2016}}
	\label{fig: stack}
\end{figure}

\subsection{Nichtlineare Datenstrukturen}
Bei nichtlinearen Datenstrukturen werden Gegensatz zu linearen Datenstrukturen die einzelnen Elemente nicht in einer sequentiellen Reihenfolge zu einander stehen \autocite[321]{hoffmann_einfuhrung_2011}. 

Die Funktionsweise sowie die Operationen nichtlinearer Datenstrukturen lassen sich nicht verallgemeinern, sondern können von Implementierung zu Implementierung abweichen. Unter nichtlinearen Datenstrukturen finden hauptsächlich vier eine breite Anwendung, nämlich Bäume (Tree), Graphen (Graph), Tabellen (Tables) und Mengen (Sets). Im Rahmen dieser Arbeit werden nur Bäume und Tabellen ausführlich behandelt.

\section{Algorithmen}

Ein Algorithmus ist ein Verfahren, welches zur Bestimmung einer oder mehreren Lösungen eines bestimmten Rechenproblems verwendet wird \autocite[1]{knebl_algorithmen_2021}. In einem Algorithmus wird ein Lösungsansatz möglichst präzise ausformuliert, indem kleine, isolierte und klar definierte Verarbeitungsschritte definiert werden. Auch ein simples Verfahren zur Summierung zwei Zahlen lässt sich als ein Algorithmus nennen. \autocite[9-10]{hubwieser_fundamente_2015}